# vim

## 基本操作
### 使用技巧
    C-[     可以代替esc
    S-j     合并行，同时可以清除空行
    C-w     插入模式中删除光标前的一个单词
    C-u     插入模式中从光标位置删除到行首
    3 C-r   重做3次
    3 u     撤销3次
    C-n     使用关键词自动完成
    C-p     使用关键词自动完成
    ctrl-z  将vi/vim 放到后台，fg 将后台vi/vim到前台
    :sh     进入shell。使用C-d或输入 exit 命令返回到vim
### DONE 插入模式
    i       在光标位置前进入插入模式
    a       在光标位置后进入插入模式
    o       在当前行的下一行添加一个空行进入插入模式
    I       在当前行的第一个非空字符进入插入模式
    A       在当前行的末尾进入插入模式
    O       在当前行的上一行添加一个空行进入插入模式
    s
    S
    以下内容只能在插入模式下可以用------------
    C-w         删除光标左侧单词
    C-u         删除光标左侧行
    C-d         减少缩进
    C-t         增加缩进
    C-y         插入模式复制上一行内容
    C-e         插入模式复制下一行内容
    M-b
    M-e
    M-w
### DONE 移动光标
    k     上
    j     下
    h     左
    l     右
    enter 移动到下一行首
    -     移动到上一行首
    0     跳转到当前行首
    ^     跳转到当前行的第一个非空字符(空格/tab)
    $     跳转到当前行的末尾
    gg    跳转到文件第一行(goto)
    G     跳转到文件最后一行
    47gg  跳转到文件第47行
    10%   跳转到文件的百分之十
### DONE 单词和文本块跳转
    w     跳转到下一个单词的开头
    3w    跳转到第三个单词的开头
    e     跳转到下一个单词的结尾
    b     跳转到上一个单词的开头
    fx    往右移动到 x 字符上
    Fx    往左移动到 x 字符上
    tx    往右移动到 x 字符前
    Tx    往左移动到 x 字符后
    ;     配合f和t使用，重复一次
    ,     配合f和t使用，反方向重复一次
    3fx   移动到第3个x字符
### 代码块跳转
    \`        跳转到某标签的光标位置
    '        跳转到某标签的行首
    ma       在当前光标位置设置位置a标记(可使用范围'a-za-z')
    \`a       跳转到 a 标记
    g;或\`.   不仅跳到最后修改的那一行，还要定位到修改点
    C-o      跳回上一次的jump
    C-i      跳回下一次的jump
    C-]      跟着link/tag转入 (follow link/tag)
    (        跳转到上一个句子的开头
    )        跳转到下一个句子的开头
    {        跳转到上一个段落的开头
    }        跳转到下一个段落的开头
    :ju      显示所有的可以跳跃的地方 (print jump list)
    %z        在当前大括号/中括号/小括号的开始位置'{/[/('和结束位置'}/]/)'之间跳转
    [[ #       跳转到上一个函数的开头(如果光标在函数体内则跳转到当前函数的开头)
    ]] #       跳转到下一个函数的开头
    [{       跳转到当前程序块的开头(当前程序块为当前程序的上一层，不是固定的)
    ]}       跳转到当前程序块的结尾
    ctrl-]   跳转到标签内部
    ctrl-t   跳转到父标签
### DONE 滚屏
    C-f   往前滚动一整屏
    C-b   往后滚动一整屏
    C-d   往前滚动半屏down
    C-u   往后滚动半屏up
    C-y   往前滚动一行
    C-e   往后滚动一行
    H     跳转到屏幕的顶部(home)
    M     跳转到屏幕的中间(middle)
    L     跳转到屏幕的底部(low)
    zt    将当前行滚动至屏幕顶部(top)
    zz    将当前行滚动至屏幕中间(同'z.')
    zb    将当前行滚动至屏幕底部(bottom)(同'z-')
### DONE 保存退出
    :q         不保存退出
    :q!        不保存强制退出
    :qa        退出所有窗口
    :qa!       强制退出所有文件
    :w         保存文件,不退出vi
    :wa        保存所有文件
    :wq        保存文件并退出vi
    :wqa       保存退出所有窗口
    :wq!       强制保存文件并退出vi
    :w!        强制保存，不退出vi
    :w [file]  另存为file文件，不退出vi
    :w! [file] 强制另存覆盖已有文件
    :e [file]  打开另一个文件
    :pwd       输出当前工作目录到状态栏
    :cd [dir]  切换当前工作目录到[dir]
    :w > [file]       将当前文件内容写入[file]文件(文件不存在，同':saveas')
    :e [dir]          打开一个目录，以例表的形式展示文件(vim7.0后续版本netrw.vim插件来实现)
    :e!               重新载入当前文件，放弃所有的修改，从上次保存文件开始再编辑
    :e! [file]        不保存当前的文件，强制打开新文件
    :r [file]         读入另一个文件，将[file]文件内容插入到下一行(read)
    :r !command       读取shell命令输出结果
    c-g               显示当前文件信息(文件名及行数等)
    gf                打开光标下的文件路径(相当于以':e'的方式打开)
    ga                显示光标下的字符在当前使用的 encoding 下的内码
    :3,9w >> [file]   将3-9行的内容追加到[file]文件末尾(文件已存在)
    :n,mw [file]      将第n-m行的文本保存到指定的文件filename中。
    :m,nw >> <file>   将 m 行到 n 行的内容添加到文件 <file> 的末尾
    :x                保存并退出，同时清除加密信息
    :x                加密保存
### 查找,替换
    /[word]            搜索[word]字符串
    ?[word]            向上搜索[word]字符串
    n                  跳转到下一个匹配的字符串(相对于搜索命令的方向)
    N                  跳转到上一个匹配的字符串(相对于搜索命令的方向)
    *                  向后搜索光标所在单词
    #                  向前搜索光标所在单词
    :s/old/new         当前行old替换成new只替换当前行第一个匹配的字符串
    :s/old/new/g       替换当前选中行所有
    :13,18s/old/new/g  替换13到18行的内容
    :%s/old/new/g      替换当前文件所有行
    :s/old/new/c       当前行old替换成new ， 只替换当前行第一个匹配的字符串
    :s/old/new/gc      替换当前行所有
    :13,18s/old/new/gc 替换13到18行的内容
    :%s/old/new/gc     替换当前文件所有行前确认
    :g/hello/d         删除含有 hello 的行
    :g!/hello/d        删除不含 hello 的行
    :v/hello/d         与 :g! 同

    :%s/^\n//g         删除空行
    :%s/^ #//g         删除行首的空格
    :%s/ #$//g         删除行尾的空格
    :s//和:g//，:!g//
    这两个命名加上正则表达式，常常能完成非常复杂的编辑任务，可以毫不夸张地说是vim的两柄瑞士军刀。:s是替换操作，:g是查找匹配模式的行，:!g是查找不匹配模式的行。

    :0,$s/^/#/gc  #在行首加一个#号
    :6,10s/^/#/gc #在6~10行的行首加一个#号

    可以用以下命令删除换行符：
    :%s/\n//g
    可以用以下命令删除DOS文件中的回车符“^M”：
    :%s/\r//g
    可以用以下命令转换DOS回车符“^M”为真正的换行符：
    :%s/\r/\r/g
    可以用以下命令删除行尾的空格以及DOS回车符。它没有使用“/”字符作为替换命令各个参数间的分隔符，而是使用了“#”字符。命令还使用了“\?”正则表达式，用来匹配它前面出现的字符0次或1次。
    :%s#\s#\r\?$##
    可以用以下命令删除三行空行：
    :%s/^\n\{3}//
    可以用以下命令将连续的两个空行替换成一个空行：
    :%s/\n\n/\r/g
    :s/aa/bb/g    将光标所在行出现的所有包含 aa 的字符串中的 aa 替换为 bb
    :s/\/bb/g   将光标所在行出现的所有 aa 替换为 bb, 仅替换 aa 这个单词
    :%s/aa/bb/g     将文档中出现的所有包含 aa 的字符串中的 aa 替换为 bb
    :12,23s/aa/bb/g 将从12行到23行中出现的所有包含 aa 的字符串中的 aa 替换为 bb
    :12,23s/^/#/ 将从12行到23行的行首加入 # 字符
    :%s= #$==    将所有行尾多余的空格删修改区域里的文本除
    :g/^s#$/d    将所有不包含字符(空格也不包含)的空行删除.

    修改区域里的文本
    :%s/w1/r2/g   将文件中所有的'w1'替换为'r2'
    :.,$s/w1/r2/g   将当前行到文件末尾所有的'w1'替换为'r2'
    :s/w1/r2/g   将当前行中所有的'w1'替换为'r2'(同':g/w1/s//r2/g')
    :3s/w1/r2/g   将第3行到文件末尾所有的'w1'替换为'r2'
    :3,9s/w1/r2/   将3-9行第一个'w1'替换为'r2'
    :3,9s/^/#/   将3-9行行首添加'#'号(可用于注释)
    :3,9s/^/\/\//   将3-9行行首添加'//'双斜线
    :3,+3s/^#//   将第3行及其后3行行首的'#'号去掉
    :.-3s/^/#/   将当前行上的第三行行首添加"#"号
    :g/print/d   删除包含'print'字符串的所有行
    :g!/print/d   删除不包含'print'字符串的所有行
    :%s/\s\+$//   去除行尾空白字符('\s'表示空白字符'空格/tab'，'\+'表示一个或多个)
    :%s/^\([a-z]\)/\u\1/   首字母大写('\1'表示第一个'\('和'\)'之间的匹配文本)
    :g/^$/,/./-j   压缩空行
    :%s/^m$//   去除行尾的'^m' ('^m'使用'<C-v><C-m>'录入)
    :%s/^i//   删除文件所有行的第一个'tab'('^i'使用'tab'键录入)
    :%s/^\d.//   删除文件所有行行首的数字和'.'(如：'5.')
    删除所有空白行(^是行的开始，\s#是零个或者多个空白字符；$是行尾)
    :g/^\s#$/d
    经实验，可以删除包括空白，tab，空白和tab交错的所有空行。
    删除空行：
    :g /^\n#$/ d
    删除空格:
    :% s/ //gi    #正则为一个空格，替换为空，全局匹配。

    :g/^\(.#\)$\n\1$/d  # 去除重复行
    :sort       # 可以直接排序
    :g/^$/d     # 删空行
    :g/^#/d     # 删除注释行
    :1,$!sort   # 将文件内的所有内容排序(1,$从第一行到最后一行，！sort  叹号引用一个shell命令）
    :%!nl       # 在所有非空行前加入行号
    :%!nl -ba   # 在所有行前加入行号,利用 linux 命令 nl 来实现的
    ga          # 显示光标所在字符的内码（包括十进制码，十六进制码以及八进制码）显示的内码为当前 encoding 下的内码
    nmap <f11> :g/^$/d<cr>:sort<cr>:g/^\(.#\)$\n\1$/d<cr>  # 删空行、排序、去重一键处理
### DONE 块操作
    v     进入可视模式，以字符为单位选择
    V     进入可视模式，以行为单位选择
    C-v   进入列块可视模式
    gv    重新选择最后选定的区域
    o
#### 块替换
   源始状态：
   chwin ch
   chwin ch
   chwin ch
   ctrl-v进入块选择模式，只选择chwin部分，按c键后输入要批量更改的字符串，然后按esc键批量更改如下：
   win ch
   win ch
   win ch
   win ch
### DONE 撤销,重复
    u              撤销(undo)
    U              行撤销，撤销所有在前一个编辑行上的操作
    <C-r>          恢复撤销前的状态
    .              重复最后一个命令
    11.            重复最后一个命令11次
    :undolist      查看撤消分支
    g-             返回较早的文本状态
    g+             返回较新的文本状态
    :earlier 10m   命令退回到10分钟前的文本状态。
    :later 5s      命令跳转到5秒以后的编辑状态。命令参数中的"s"代表秒，"m"代表分钟，"h"代表小时。
    :undo          命令并指定编号做为参数，则能够撤销到某个分支。
    qq             录制到q
    ..             输入一系列复杂的指令
    q              再次按q停止录制
    @q             执行q中存储的指令
    @@             重复执行
    5@q            表示重复执行宏q 5次
### 复制,粘贴
    y                抽出选择的文本到寄存器(可视模式)(yank/copy)
    "+y              抽出选择的文本到系统剪切板(可视模式)(好像不太好使)
    yy               复制当前行
    5yy              表示拷贝光标以下 5 行.
    yw               复制光标之后的单词剩余部分(yank word)
    yb               复制光标之前的单词剩余部分
    yiw              复制一个单词
    yip              复制当前段落(yank inner paragraph)
    yas              复制一个句子(yank a sentence)
    yi<              复制尖括号之间的内容(yank inner <>)
    y$               复制光标位置到行尾
    y^               复制光标位置到行首
    yfa              表示拷贝从当前光标到光标后面的第一个a字符之间的内容.
    y2fa             表示拷贝从当前光标到光标后面的第二个a字符之间的内容.
    :12,24y          表示拷贝第12行到第24行之间的内容.
    :12,y            表示拷贝第12行到光标所在行之间的内容.
    :,24y            表示拷贝光标所在行到第24行之间的内容. 删除类似.
    y                将选取的内容拷入剪贴板
    p                将剪贴板中的内容粘贴在光标后(小写p)
    p                将剪贴板中的内容粘贴在光标前(大写p)
    <C-r>"           粘贴(插入模式)
    "ayy             复制当前行到寄存器'a'(可使用范围'a-z')
    "ap              粘贴从寄存器'a'

    使用"+y或者"#y   可以将visual mode下选择的内容拷贝到系统剪切板，使用"+p或者"#p可以将剪切板中的内容粘贴到vim中，如果打开了

    寄存器
    ""       无名寄存器,最近一次删除/修改/替换操作的文本都会放入这个寄存器
    0-9      10个数字寄存器，拷贝或者删除的文本存入这些寄存器，这些寄存器是循环使用的，在每次存入内容到寄存器1时，原有的内容会依次存入到后一个寄存器中。
    -        小删除寄存器，删除内容少于一行时放入这个寄存器。
    a-za-z   26个命名寄存器，大小写无关。这些寄存器可以在拷贝或者删除等操作中指定使用。
    :.%      # 四个只读寄存器
    =        表达式寄存器
    #+~      选择和拖放寄存器, 用于与系统剪切板交互，以及接收拖放操作的内容。
    _        黑洞寄存器, 放到这里面的内容都被丢弃，这样可以删除或拷贝时不影响其它寄存器。
    /        最后一次搜索模式寄存器,保存最后一次搜索的正则表达式。
    :reg     查看所有寄存器中的内容
### DONE 缓冲区
    :ls             查看缓冲区列表
    :bn             编辑下一个缓冲区(buffer next)
    :bp             编辑上一个缓冲区(buffer previous)
    :b[n]           编辑缓冲区列表中第[n]个缓冲区
    :b a.txt        编辑缓冲区列表中 a.txt 缓冲区
    :bd             卸载当前缓冲区(buffer delete)
    :bn             跳转到下一个buffer
    :bp             跳转到上一个buffer
    :wn             存盘当前文件并跳转到下一个(又是“超级……”,ft!)
    :wp             存盘当前文件并跳转到上一个
    :bd             把这个文件从buffer列表中做掉
    :bun            卸掉buffer (关闭这个buffer的窗口但是不把它从列表中做掉)
    :badd file.c    把文件file.c添加到buffer列表
    :b 3            跳到第3个buffer
    :b main         跳到一个名字中包含main的buffer,例如main.c               : (ultra，这个怎么翻译？:()
    :sav php.html   把当前文件存为php.html并打开php.html
    :sav! %<.bak    换一个后缀保存
### 删除文本
    D=d$
    C=c$
    Y=y$
    xp         交换两个字符位置，其实就是删除光标当前字符(x)，然后再将缓存的字符贴出(p)
    ddp        上下两行调换，实际就是(dd)删除当前行，(p)后即将缓存的行贴出
    dl
    dh
    dk         向上删一行
    dj         向下删一行
    dh         向左删一个字符
    dl         向右删一个字符
    3dk        向上删3行
    x          向后删除一个字符 (相当于 [del] 按键)
    X          向前删除一个字符(相当于 [backspace] 亦即是退格键)
    dgg        删除光标所在到第一行的所有数据
    d/text     删除从文本中出现"text"中所指定字样的位置，一直向前直到下一个该字样所出现的位置（但不包括该字样）之间的内容
    dG         删除光标所在到最后一行的所有数据
    dw         删当前字符到单词尾（包括空格） 3dw  (delete word)
    de         删当前字符到单词尾（不包括空格） 3de
    db         删除到某个单词的开始位置
    diw        删除一个单词
    dd         删除当前行  3dd
    :5,10d     删除5-10行
    d0         删除到行首
    d^         删除到行的第一个非空字符(空格/tab)
    d$         删除光标位置到行尾
    d)         删除从光标位置到下一个句子的开始
    d}         删除从光标位置到该段落的末尾
    di{        删除花括号之间的内容(delete inner {})(同'dib')
    di(        删除小括号之间的内容(delete inner ())(同'dib')
    dit        删除闭合标签之间的内容(html/xml等标签，delete inner tag)
    dat        删除左右尖括号及之间的内容(delete a tag)
    da<        删除左右尖括号及之间的内容(delete a <>)
    di"        删除引号之间的内容(delete inner "")
    da"        删除左右引号及之间的内容(delete a "")
    df[char]   删除从光标位置到[char]字符(delete find [char])
    dfa        删除从当前光标到光标后面的第一个a字符之间的内容.
    dtc        删除当前行直到下一个字符"c"所出现位置之间的内容
    C-w        删除光标前的一个单词(插入模式)
    C-u        从光标位置删除到行首(插入模式)
    C-h        删除一个字符，等同退格
    dG         删除直到工作缓存区结尾的内容
    d1g        删除直到工作缓存区开始的内容
### 修改命令操作
    r          替换单个字符
    R          替换多个字符
    c          修改区域里的文本
    cc         修改整行
    5cc        修改从当前行所开始的5行内容
    cl         更改当前字符
    cf[char]   删除从光标位置到[char]字符并进入插入模式
    ce         删除光标之后的一个单词
    cw         修改到某个以空格作为分隔符的单词的结尾位置
    c3w        修改到第三个单词的结尾位置
    cb         修改到某个单词的开始位置
    cb         修改到某个以空格作为分隔符的单词的开始位置
    c7b        修改到前面7个以空格作为分隔符的单词的开始位置
    c0         修改到行首
    c^         修改到行首非空格位置
    c$         修改到行尾
    c          修改到行尾
    c）        修改到某个语句的结尾位置
    c4）       修改到第四个语句的结尾位置
    c（        修改到某个语句的开始位置
    c}         修改到某个段落的结尾位置
    c{         修改到某个段落的开始位置
    c7{        修改到当前段落起始位置之前的第7个段落位置
    ctc        修改当前行直到下一个字符c所出现位置之间的内容
### 更改文本
    J      将下一行合并的当前行的末尾
    5J     合并从当前行开始连续5行的文本
    3,9J   合并3-9行
    ~      切换光标下字符的大小写
    v ~    先用v选择要修改的字符串，再按~键可一次性修改多个字符串的大小写。
    u      更改选定的文本为小写(可视模式)
    U      更改选定的文本为大写(可视模式)
    guw    将光标所在的单词变为小写
    gUw    将光标所在的单词变为大写
    guu    光标所在的行所有字符变为小写
    gUU    光标所在的行所有字符变为大写
    g~~    光标所在的行所有字符大小写反向转换
    C-a    把当前光标下或之后的数值加1
    C-x    把当前光标下或之后的数值减1
### 对齐
#### 缩进，对齐
   >>          缩进当前行
   <<          向左缩进当前行
   <C-d>       缩进当前行(插入模式)
   <C-t>       向左缩进当前行(插入模式)
   :3,9>>>>>   将3-9行缩进5个tab
   >           缩进选定的行(可视模式)
   <           向左缩进选定的行(可视模式)
   >i{         缩进花括号之间的内容(indent inner {})(同'>ib')
   >a{         缩进花括号及之间的内容(indent a {})(同'>ab')
   =}          缩进当前段落
   gg=g        全文缩进/格式化
   >           向右缩进两（需要按回车）
   >g          缩进到文件尾部
   >gg         缩进到文件顶部
   >>          向右缩进当前行（不需要按回车）
   5>>         向下缩进5行
   >8k         向上缩进8行
   :12,24>     将12行到14行向右移动一个tab
   :12,24>>    将12行到14行的数据都向右移动两个tab
   v           （进入visual模式），选中部分行，然后按＝对齐到左边界
   =g          当前行到文件尾部对齐到左边界
   =5          向下5行对齐到左边界
   :5,10>>     第5-10行向右缩进两个tab
   :5,10<      第5-10行向左缩进一个tab
#### 居中对齐
   :{range} center [width]
   {range} 即是那些通常命令所能指定的范围。 [width] 是一个可选项，用来确定要居中
   的行的宽度。如果没有指定 [width]，则默认使用 'textwidth' 的值。(如果
   'textwidth' 是 0，则默认为 80。)
   例如:
   :1,5center 40
#### 右对齐
   类似地，":right" 命令将使文本右对齐:
   :1,5right 37
#### 左对齐
   我们使用这个命令:
   :{range} left [margin]
   和 ":center" ":right" 不同的是，":left" 的参数并不是行的宽度，而是左边的页边
   距。如果这个参数被省略了，文本将被紧靠在屏幕的左边缘 (用一个零页边距参数将得
   到一样的效果)。如果页边距是 5，文本将缩进五个空格。举个例子，使用以下命令:
   :1left 5
   :2,5left
### 窗口
#### 命令行编辑窗口
   q:            # 正常模式下输入q:开命令行窗口查看、执行输入过的命令。编辑新的命令或修改旧的命令。可以拷贝粘贴。
   :%s/ C-f p # 假定要将123替换成456，现yw复制123，然后在底行输入 :%s/ 这个时候输入C-f, 会在当前窗口下面出现一个小窗口用来编辑命令。在这个新窗口用p将123粘贴过来就可以了。剩下的命令要直接在这个新窗口完成。
   :C-r       # 命令窗口下粘贴。先在普通模式下用y复制。到命令行模式下ctrl-r然后“进行粘贴，可重复多次粘贴
   C-cc       # 关闭命令行窗口
#### 分割窗口
   vi passwd fstab inittab 多文件操作
   :args 查看多文件状态，可以简写成ar
   :next 切换下一个文件
   :prev 切换上一个
   :next! 切换下一个文件，并强制丢弃修改
   :prev! 切换上一个文件，并强制丢弃修改
   :first 首文件
   :last 尾文件
   C-^ 切换两个其它切换命令切换后的两个文件

   :ex            #开启目录浏览器，可以浏览当前目录下的所有文件，并可以选择
   :tabnew        # 标签命令 gt gt 进行标签切换
   vim  -o5 /a /b # 将分配5个相同的窗口，有3个是闲置的
   vim -o2        # 垂直分两个屏
   vim -o /a /b   # 垂直分屏打开两个文件
   vim -o /a /b   # 水平打开现个文件
   vim -d /a /b   # 垂直diff两个文件
   vim -do /a /b  # 垂直分屏比较两个文件
   :sp            # 水平分割当前窗口(split)
   :sp [file]     # 水平分割一个新窗口，并编辑文件[file]
   :vs            # 垂直分割当前窗口(vertical split)
   :vs [file]     # 垂直分割一个新窗口，并编辑文件[file]
   :only          # 关闭其他窗口
   C-w n  # 新建一个缓冲区
   C-w c  # 关闭当前窗口,  与q的区别是不能退出最后一个窗口
   C-w q  # 退出光标所在的缓冲区，如果只剩最后一个了，则退出vim
   C-w v  # 左右切割窗口新建缓冲区
   C-w s  # 上下切割窗口新建缓冲区
   C-w o  # 使光标所在缓冲区最大化，其他缓冲区隐藏
   C-w w  # 窗口之间切换
   C-w 3j # 向下移动3个窗口(其他方向等同)
   C-w l  # 移到右边窗口
   C-w h  # 移到左边窗口
   C-w k  # 移到上边窗口
   C-w j  # 移到下边窗口
   C-w l  # 移动到最右边窗口
   C-w h  # 移动到最左边窗口
   C-w k  # 移动到最上边窗口
   C-w j  # 移动到最下边窗口
   C-w <  # 向左增加宽度
   C-w >  # 向右增加宽度
   C-w w  # 这个命令会在所有窗口中循环移动
   C-w t  # 移动到最左上角的窗口
   C-w b  # 移动到最右下角的窗口
   C-w p  # 移动到前一个访问的窗口
   C-w r  # 向右或向下方交换窗口，而ctrl + w + r则和它方向相反。
   C-w x  # 交换同列或同行的窗口的位置
   C-w =  # 让所有的窗口等同大
   C-w +  # 增加高度
   C-w -  # 减少高度
   C-w    # 最大宽度
   C-w 1  # 最小宽度
### 折叠

    3zF # 创建折叠操作符，并折叠3行
    zo  # 打开光标下的折叠(open)
    zc  # 关闭光标下的折叠(close)
    zR  # 打开所有的折叠
    zd  # 删除光标下的折叠操作符(delete)

    set foldenable              " 开始折叠
    set foldmethod=syntax       " 设置语法折叠
    set foldcolumn=0            " 设置折叠区域的宽度
    setlocal foldlevel=1        " 设置折叠层数为
    " set foldclose=all           " 设置为自动关闭折叠
    " nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>
    "设置折叠模式
    set foldcolumn=4
    "光标遇到折叠，折叠就打开
    "set foldopen=all
    "移开折叠时自动关闭折叠
    "set foldclose=all
    "zf zo zc zd zr zm zR zM zn zi zN
    "依缩进折叠
    "   manual  手工定义折叠
    "   indent  更多的缩进表示更高级别的折叠
    "   expr    用表达式来定义折叠
    "   syntax  用语法高亮来定义折叠
    "   diff    对没有更改的文本进行折叠
    "   marker  对文中的标志折叠
    set foldmethod=syntax
    "启动时不要自动折叠代码
    set foldlevel=100
    "依标记折叠
    set foldmethod=marker
    " 用空格键来开关折叠
    在VIM下,折叠文本一般情况下我是使用Visual模式选中一些文本,然后用zf命令把他折叠出来,但是经常使用visual模式,感觉不是很方便,不过经常使用感觉不是很方便,找到帮助时.发现可以使用命令模式:开始行号,结束行号folder命令就可以折叠了,
    同样多行缩进可以使用:110,120>来将110行到120行缩进
    复制:110,120 yank 复制到默认寄存器
    或者:110,120 yank x 复制到x寄存器
    1. 折叠方式
    可用选项 'foldmethod' 来设定折叠方式：set fdm=#####。
    有 6 种方法来选定折叠：
    manual           手工定义折叠
    indent             更多的缩进表示更高级别的折叠
    expr                用表达式来定义折叠
    syntax             用语法高亮来定义折叠
    diff                  对没有更改的文本进行折叠
    marker            对文中的标志折叠
    注意，每一种折叠方式不兼容，如不能即用expr又用marker方式，我主要轮流使用indent和marker方式进行折叠。
    使用时，用：set fdm=marker 命令来设置成marker折叠方式（fdm是foldmethod的缩写）。
    要使每次打开vim时折叠都生效，则在.vimrc文件中添加设置，如添加：set fdm=syntax，就像添加其它的初始化设置一样。
    2. 折叠命令
    选取了折叠方式后，我们就可以对某些代码实施我们需要的折叠了，由于我使用indent和marker稍微多一些，故以它们的使用为例：
    如果使用了indent方式，vim会自动的对大括号的中间部分进行折叠，我们可以直接使用这些现成的折叠成果。
    在可折叠处（大括号中间）：
    zc      折叠
    zC     对所在范围内所有嵌套的折叠点进行折叠
    zo      展开折叠
    zO     对所在范围内所有嵌套的折叠点展开
    [z       到当前打开的折叠的开始处。
    ]z       到当前打开的折叠的末尾处。
    zj       向下移动。到达下一个折叠的开始处。关闭的折叠也被计入。
    zk      向上移动到前一折叠的结束处。关闭的折叠也被计入。
    当使用marker方式时，需要用标计来标识代码的折叠，系统默认是{{{和}}}，最好不要改动之：）
    我们可以使用下面的命令来创建和删除折叠：
    zf      创建折叠，比如在marker方式下：
    zf56G，创建从当前行起到56行的代码折叠；
    10zf或10zf+或zf10↓，创建从当前行起到后10行的代码折叠。
    10zf-或zf10↑，创建从当前行起到之前10行的代码折叠。
    在括号处zf%，创建从当前行起到对应的匹配的括号上去（（），{}，[]，<>等）。
    zd      删除 (delete) 在光标下的折叠。仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效。
    zD     循环删除 (Delete) 光标下的折叠，即嵌套删除折叠。
    仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效。
    zE     除去 (Eliminate) 窗口里“所有”的折叠。
    仅当 'foldmethod' 设为 "manual" 或 "marker" 时有效。
## 杂货铺
    # GVIM 不同的地方
    gvim -d file1 file2        : vimdiff (比较不同)
    dp                         : 把光标处的不同放到另一个文件
    do                         : 在光标处从另一个文件取得不同
    ----------------------------------------
    # 把东西送到命令行/搜索行
    <C-R><C-W>              : 送一个狭义词
    <C-R><C-A>              : 送一个广义词
    <C-R>-                  : 送一个小型删除寄存器register
    <C-R>[0-9a-z]           : 送一个命名寄存器register
    <C-R>%                  : 送文件名过去 (#也行)

    等价的:
    x=dl
    X=dh
    D=d$
    C=c$
    ----------------------------------------
      # # g# g#     寻找光标处的狭义单词(<cword>) (前向/后向)
      <C-N><C-P>    插入模式下的单词自动完成
      <C-X><C-L>    整行补全(超级有用)
      /<C-R><C-W>   把狭义单词 <cword> 写到 搜索命令 行
      /<C-R><C-A>   把广义单词 <cWORD> 写到 搜索命令 行
    # 编辑register/录制
    \"ap #把register a中的内容贴到当前位置
    .. #现在你可以修改它了
    \"add#删除之，重新存入register a
    @a  #执行register a中的指令
    ----------------------------------------
    # 列出寄存器(Registers)
    :reg             : 显示所有当前的registers
    \"1p              : \"表示引用register，1表示一个名字叫做1的register，
                     : p就是粘贴（paste）命令
    # 译释：\"也用来定义register
    # 先输入 \",表示定义register
    # 然后输入名字，如0~9,a~z
    # 然后执行删除或复制命令，如dd或y，
    #         或者是visual模式下的d(删除选中的部分)或y(复制选中的部分)
    # 则被删除或复制的部分就被存入了这个命名的register
    #
    # 观察：一个特殊的register, \"\" ，里面存储了一个匿名的删除/复制
    # 在你执行dd或y的时候，被作用的部分被存到了\"\"中
    # 这些和perl是多么像啊
    # 标记和移动
    \'.               : 跳到最后修改的那一行 (超级有用)(ft,怎么又是这个评价)
    `.               : 不仅跳到最后修改的那一行，还要定位到修改点
    <C-O>            : 依次沿着你的跳转记录向回跳 (从最近的一次开始)
    <C-I>            : 依次沿着你的跳转记录向前跳
    :ju(mps)         : 列出你跳转的足迹
    :help jump-motions
    :history         : 列出历史命令记录
    :his c           : 命令行命令历史
    :his s           : 搜索命令历史
    q/               : 搜索命令历史的窗口
    q:               : 命令行命令历史的窗口
    :<C-F>           : 历史命令记录的窗口
    ----------------------------------------
    # 文件浏览
    :Ex                             : 开启目录浏览器，注意首字母E是大写的
    :Sex                            : 在一个分割的窗口中开启目录浏览器
    :ls                             : 显示当前buffer的情况
    :cd ..                          : 进入父目录
    :args                           : 显示目前打开的文件
    :lcd %:p:h                      : 更改到当前文件所在的目录
    # 译释：lcd是紧紧改变当前窗口的工作路径，% 是代表当前文件的文件名,
    # 加上 :p扩展成全名（就是带了路径），加上 :h析取出路径\r\n:autocmd BufEnter # lcd %:p:h   : 自动更改到当前文件所在的目录
    # 译释：autocmd指定一个自动命令，BufEnter指定一个事件，# 指定事件的对象，
    # lcd %:p:h 指定一个动作
    # hehe,好像和写记叙文差不多
    # 基础
