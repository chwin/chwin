#+TITLE: 好记性不如烂笔头--温故而知新
#+TAGS: ch(c) 编辑器(e) 浏览器(f) 多媒体(m) 压缩(z)

* Python
** 基础
*** 代码抬头
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-

*** print()
    print('a','b','c')
    print(100 + 200)
    print('100 + 200 =', 100+200)

*** input()
    name = input()
    print('hello,',name)

    name = input('please enter your name: ')
    print('hello,', name)

*** 代码片段
    # print absolute value of an integer:
    a = 100
    if a >= 0:
        print(a)
    else:
        print(-a)
*** 数据类型
**** 整数
     Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。
     计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。
**** 浮点数
     浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。
     整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。
**** 字符窜
     字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。
     'I\'m \"OK\"!'

     >>> print('I\'m ok.')
     I'm ok.
     >>> print('I\'m learning\nPython.')
     I'm learning
     Python.
     >>> print('\\\n\\')
     \
     \
* emacs
** 李杀配置
*** init文件
    (add-to-list 'load-path "~/.emacs.d/ergoemacs-mode")
    (require 'ergoemacs-mode)

    (setq ergoemacs-theme nil) ;; Uses Standard Ergoemacs keyboard theme
    (setq ergoemacs-keyboard-layout "us") ;; Assumes QWERTY keyboard layout
    (ergoemacs-mode 1)
*** 安装
    cd ~/.emacs.d
    git clone -b master --single-branch https://github.com/ergoemacs/ergoemacs-mode.git
** org-mode
*** 基本操作

    |----------------+-----------------------------------------------------------------|
    | <TAB>          | 对当前结点进行切换：收缩→查看所有子结点→查看所有内容          |
    | <SHIFT>-<TAB>  | 对当前文件进行切换：收缩→查看所有子结点→查看所有内容          |
    | M-<ENTER>      | 插入一个同级别的标题                                            |
    | M-S-<ENTER>    | 插入一个同级别的TODO标题                                        |
    | M-LEFT/RIGHT   | 将当前标题升/降级                                               |
    | M-S-LEFT/RIGHT | 将子树升/降级                                                   |
    | M-UP/DOWN      | 将当前标题上移/下移                                             |
    | M-S-UP/DOWN    | 将子树上/下移动                                                 |
    | C-c C-n        | 移动到下一个标题                                                |
    | C-c C-p        | 移动到上一个标题                                                |
    | C-c C-f        | 移动到和当前标题同等级的下一个标题                              |
    | C-c C-b        | 移动到和当前标题同等级的上一个标题                              |
    | C-c C-u        | 向上移动到更高一层的标题                                        |
    | C-c C-w        | 将子树或者区域移动到另一个标题处（跨缓冲区）                    |
    |----------------+-----------------------------------------------------------------|
    | C-c C-t        | 切换当前结点的状态                                              |
    | C-c [          | 将当前文件设置为事件视图的数据源                                |
    | C-c ]          | 从事件视力的数据源中删除当前文件（数据源）                      |
    | C-c *          | 将本行设为标题或者正文                                          |
    | C-c C-x b      | 在新缓冲区显示当前分支                                          |
    | C-c /          | 只列出包含搜索结果的大纲，并高亮，支持多种搜索方式              |
    | C-c l          | 创建一个跳转目标点                                              |
    | C-c C-o        | 访问链接                                                        |
    | C-c %          | 可以记录当前光标所在位置                                        |
    | C-c &          | 跳转回来记录光标位置                                            |
    | C-c C-e        | 可以导出成各种格式，包括自动用latex生成pdf，这个功能部分取代lyx |
    | C-c .          | 在光标位置插入时间                                              |
    |----------------+-----------------------------------------------------------------|
    | C-c 竖线       | 创建或者转化成表格                                              |
    | C-c C-c        | 调整表格，不移动光标                                            |
    | TAB            | 移动到下一区域，必要时新建一行                                  |
    | S-TAB          | 移动到上一区域                                                  |
    | RET            | 移动到下一行，必要时新建一行                                    |
    | M-LEFT/RIGHT   | 移动列                                                          |
    | M-UP/DOWN      | 移动行                                                          |
    | M-S-LEFT/RIGHT | 删除/插入列                                                     |
    | M-S-UP/DOWN    | 删除/插入行                                                     |
    | C-c -          | 添加水平分割线                                                  |
    | C-c RET        | 添加水平分割线并跳到下一行                                      |
    | C-c ^          | 根据当前列排序，可以选择排序方式                                |
    |----------------+-----------------------------------------------------------------|

*** 格式导出与发布
**** 导出
     |-----------+------------------|
     | C-c C-e a | 导出为文本文件。 |
     | C-c C-e h | 导出为 HTML 文件 |
     |-----------+------------------|

**** 发布
     |-----------+------------------------------------|
     | C-c C-e C | 提示指明一个项目，将所有的文件发布 |
     | C-c C-e P | 发布包含当前文件的项目             |
     | C-c C-e F | 只发布当前文件                     |
     | C-c C-e E | 发布所有项目                       |
     |-----------+------------------------------------|

*粗体*
/斜体/
+删除线+
_下划线_
下标： H_2 O(这里必须留一个空格要不然2和O都成为小标，目前还不知道怎么去掉空格)
上标： E=mc^2
等宽字：  =git=

** 高手配置

   bbatsov/prelude · GitHub 　这个配置可以说是实现了emacs的又一个发行版。
   purcell/emacs.d · GitHub 　注重于web编程的世界级配置。
   eschulte/emacs24-starter-kit · GitHub 一个emacs完全入门的emacs配置，这是一个奇特的文学工程，也就是说把配置文件巧妙地放进了教程当中，学习emacs的顶级配置。
   xiaohanyu/oh-my-emacs · GitHub 他的作者是中国人，但是github的fork数目确很可观，是一个世界级配置，他继承了前面的prelude和emacs24-starter-kit的优点，然后加入了更多的功能，比如python语言的elpy终极配置，c语言的clang补全。
   redguardtoo/emacs.d · GitHub 这款配置的作者是 @陈斌， emacs绝对高手，他的配置在几年前fork自purcell的配置，然后多年来自己调教，非常优秀。

** 配置文件
*** 包管理
**** 配置包服务器
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("melpa" . "http://melpa.org/packages/")
   t)
  (package-initialize))
**** 包管理命令
     M-x ielm 打开Emacs Lisp交互解释器
    | M-x list-packages | 调用包管理                             |
    | C-s packname      | 搜索一个包                             |
    | <Enter>           | 查看包信息                             |
    | i                 | 标记安装包                             |
    | u                 | 撤销标记包                             |
    | d                 | 标记删除包                             |
    | x                 | 执行安装标记包                         |
    | r                 | 刷新包服务器列表                       |
    | U                 | 标记所有序号更新的包                   |
    | C-h m             | describe-mode  显示所有包命令（C-h m） |
    | C-h f             | describe-function                      |
    | C-h v             | describe-variable                      |
    |                   | locate-library 查找本地包              |
    |                   |                                        |
*** 不重动 Emacs 让 .emacs 配置文件生效
    有四个函数可以做到：eval-last-sexp,eval-region,eval-buffer 和load-file
    M-x eval-last-sexp 使.emacs中光标前的那一条语句立刻生效。
    M-x eval-region 使.emacs中选中的region中的语句立刻生效。
    M-x eval-buffer 使当前的buffer中的设置语句立刻生效。
    M-x load-file ~/.emacs 载入.emacs文件，从而使其中的设置生效。

    M-x sort-lines 排序选中行。
    M-x dig
    M-x ifconfig
    M-x ping
    M-x telnet
    M-z 删除到某个字符，同Vim的 df
    C-u M-! date 插入当前时间

*** 光标移动
    (global-set-key (kbd "C-w") 'previous-line) ;; 上
    (global-set-key (kbd "C-s") 'next-line) ;;下
    (global-set-key (kbd "C-a") 'backward-char) ;; 左
    (global-set-key (kbd "C-d") 'forward-char) ;;右
    (global-set-key (kbd "C-q") 'move-beginning-of-line) ;;行首
    (global-set-key (kbd "C-e") 'move-end-of-line) ;;行尾
    (global-set-key (kbd "M-w") 'scroll-down) ;;上翻页
    (global-set-key (kbd "M-s") 'scroll-up) ;;下翻页
    ;(global-set-key (kbd "C-x e") 'beginning-of-buffer) ;;文件首
    ;(global-set-key (kbd "C-x d") 'end-of-buffer) ;;文件尾
    (global-set-key (kbd "C-f") 'delete-char) ;;删除字符
    (global-set-key (kbd "M-f") 'kill-line) ;;删除行
    ;(global-set-key (kbd "C-x") 'kill-region) ;;剪切
    (global-set-key (kbd "C-c") 'kill-ring-save) ;;复制
    (global-set-key (kbd "C-v") 'yank) ;;粘贴
    (global-set-key (kbd "M-g") 'undo) ;;重做
    (global-set-key (kbd "M-,") 'execute-extended-command)
*** 设置启动窗口初始位置大小
    ;;设置窗口位置为屏库左上角(0,0)
    (set-frame-position (selected-frame) 0 0)
    ;;设置宽和高
    (set-frame-width (selected-frame) 110)
    (set-frame-height (selected-frame) 33)
****
M-x load-file ~/.emacs




(setq org-hide-leading-stars t)
;; (define-key global-map "\C-c a" 'org-agenda)
 (setq org-log-done 'time)


(autoload 'markdown-mode "markdown-mode"
   "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

;;让 Emacs 可以直接打开和显示图片。
(setq auto-image-file-mode t)
(setq x-select-enable-clipboard t);允许emacs和外部其他程序的粘贴

;; 改变 Emacs 固执的要你回答 yes 的行为。按 y 或空格键表示 yes，n 表示 no。
(fset 'yes-or-no-p 'y-or-n-p)

;;设置缺省主模式是text，,并进入auto-fill次模式.而不是基本模式fundamental-mode
(setq default-major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)

;; 大纲模式自动缩进
(setq org-startup-indented t)

;;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
;;&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


;; 显示时间设置
(display-time-mode 1);;启用时间显示设置，在minibuffer上面的那个杠上
(setq display-time-24hr-format t);;时间使用24小时制
(setq display-time-day-and-date t);;时间显示包括日期和具体时间
(setq display-time-use-mail-icon t);;时间栏旁边启用邮件设置
(setq display-time-interval 10);;时间的变化频率，单位多少来着？

;;设置打开文件的缺省路径，这里为桌面，默认的路径为“～/”
(setq default-directory "d:/chwin/")

;;防止页面滚动时跳动，
;;=================================
;;scroll-margin 3 可以在靠近屏幕边沿3行时就开始滚动
;;scroll-step 1 设置为每次翻滚一行，可以使页面更连续
(setq scroll-step 1 scroll-margin 3 scroll-conservatively 10000)

;; =================================
;; 取消工具栏
(tool-bar-mode 0)
(menu-bar-mode 0)
(scroll-bar-mode 0)

;; =================================
;; 设置字体
;; Setting English Font
(set-face-attribute
  'default nil :font "Consolas 14")
;; Chinese Font
(dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font)
                      charset
                      (font-spec :family "Microsoft Yahei" :size 16)))

;; =================================
;; 设置当前行注解
(defun qiang-comment-dwim-line (&optional arg)
  "Replacement for the comment-dwim command.
If no region is selected and current line is not blank and we are not at the end of the line,
then comment current line.
Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
      (comment-or-uncomment-region (line-beginning-position) (line-end-position))
    (comment-dwim arg)))
    (global-set-key "\M-;" 'qiang-comment-dwim-line)
*** 基本设置
;; =================================
;; 去除启动欢迎页面
(setq inhibit-startup-message t)
;; =================================
;; 显示行号
(global-linum-mode t)
;; 显示列号
(setq column-number-mode t)
;; =================================
;;关闭备份文件#xxx#
(setq auto-save-default nil)
;; =================================
;;关闭烦人的出错时的提示声
(setq visible-bell t)
;; =================================
;; 改变 Emacs 固执的要你回答 yes 的行为。按 y 或空格键表示 yes，n 表示 no
(fset 'yes-or-no-p 'y-or-n-p)
;; =================================
;;可以将备份文件全部放到~/.backups目录下。
(setq backup-directory-alist (quote (("." . "~/.backups"))))
再介绍下恢复文件，一般"#youfile #"就是你上次未保存(或者意外死机没保存)的文件内容，打开原文件emacs会提示你可以自动恢复文件，
M-x recover-file <RET> 文件名 <RET>
yes <RET>
C-x C-s
;; =================================
;; =================================
;; =================================
*** 快捷键绑定
(global-set-key [M-f1] 'shell);F1进入Shell
(global-set-key [M-f2] 'python-shell);F2进入Python-Shell
;(global-set-key (kbd "C-`") 'eval-buffer);配置文件生效
;(global-set-key [f5] 'gdb);F5调试程序
;(setq compile-command "make -f Makefile")
;(global-set-key [f7] 'do-compile);F7编译文件
;(global-set-key [f3] 'other-window);F3窗口间跳转
;(global-set-key [f4] 'delete-other-windows);F4 关闭其它窗口
;(global-set-key [C-return] 'kill-this-buffer);C-return关闭当前buffer
;(global-set-key [f1] 'split-window-vertically);F1分割窗口
;(global-set-key (kbd "C-,") 'backward-page);文件首
;(global-set-key (kbd "C-.") 'forward-page);文件尾
*** 文字跳转
;; C-t	文字跳转  通过这个，我们可以通过 C-t 加上指定字符向后跳，后者 C-u C-t 向前跳。比如C-t w w w w …就一直往后跳到后续的w处。类似于Vim中的fw;;;…
(defun my-go-to-char (n char)
  "Move forward to Nth occurence of CHAR.
Typing `my-go-to-char-key' again will move forwad to the next Nth
occurence of CHAR."
  (interactive "p\ncGo to char: ")
  (let ((case-fold-search nil))
    (if (eq n 1)
        (progn                            ; forward
          (search-forward (string char) nil nil n)
          (backward-char)
          (while (equal (read-key)
                        char)
            (forward-char)
            (search-forward (string char) nil nil n)
            (backward-char)))
      (progn                              ; backward
        (search-backward (string char) nil nil )
        (while (equal (read-key)
                      char)
          (search-backward (string char) nil nil )))))
  (setq unread-command-events (list last-input-event)))
  (global-set-key (kbd "C-t") 'my-go-to-char)
** 基本操作
*** 移动

    |-----------+--------------------|
    | M-g M-g 5 | 跳转到第五行       |
    | C-b       | 前一个字符         |
    | C-f       | 后一个字符         |
    | C-p       | 上一行             |
    | C-n       | 下一行             |
    | M-f       | 后一个单词         |
    | M-b       | 前一个单词         |
    | C-a       | 行首               |
    | C-e       | 行尾               |
    | M-a       | 移动到句首         |
    | M-e       | 移动到句尾         |
    | C-v       | 向下翻一页         |
    | M-v       | 向上翻一页         |
    | C-l       | 上、中、下切换屏幕 |
    | M-{       | 段落开头           |
    | M-}       | 段落结尾           |
    | M-<       | 到文件开头         |
    | M->       | 到文件末尾         |
    |-----------+--------------------|

    M-a 左移
    M-d 右移
    M-w 上移
    M-s 下移
    M-e 行首
    M-q 行尾
    C-a 左移词
    C-d 右移词
    C-w 上翻页
    C-s 下翻页
    C-e 句首
    C-q 句尾
    C-M-e 段首
    C-M-q 段尾
    M-S-e 文件首
    M-S-q 文件尾

    M-1 只显示主窗口
    M-2 上下分割窗口
    M-3 左右分割窗口
    M-4 关闭窗口
    M-` 跳转窗口

*** 文本编辑
| M-n/C-u n | 重复执行后一个命令n次                      |
| C-d       | 删除后一个字符                             |
| M-d       | 删除后一个单词                             |
| Del       | 删除前一个字符                             |
| M-Del     | 删除前一个单词                             |
| C-k       | 移除一行                                   |
| M-k       | 移除一句                                   |
| C-<SPC>   | 设定标志位(主要是为了粘贴剪切以及删除使用) |
| M-h       | 标记一个段落                               |
| C-x h     | 标记整个缓冲区                             |
| C-x C-x   | 交换插入点和文本标记位置                   |
| C-w       | 移除标记区域的内容（剪切）                 |
| M-w       | 复制标记区域的内容（复制）                 |
| C-y       | 召回(yank)复制/移除的区域/行（粘贴）       |
| M-y       | 召回更早的内容 (在kill缓冲区内循环)        |
| C-t       | 交换两个字符的位置                         |
| M-t       | 交换两个单词的位置                         |
| C-x C-t   | 交换两行的位置                             |
| M-u       | 使从光标位置到单词结尾处的字母变成大写     |
| M-l       | 与M-u相反                                  |
| M-c       | 使从光标位置开始的单词的首字母变为大写     |

C-r 移除一行
M-r 移除一句
C-f 剪切
M-f 复制
C-v 召回
M-v 召回更早的内容
M-z 撤销

*** 窗口命令
C-x 0    关闭窗格
C-x 1    关闭除了光标所在窗格外所有窗格
C-x 2    水平分割窗格
C-x 3    垂直分割窗格
C-x o    切换至其他窗格
C-x C-b    列出所有缓冲区
C-x b      切换缓冲区
C-x s      保存多个缓冲区

C-x     字符扩展。  C-x 之后输入另一个字符或者组合键。
M-x     命令名扩展。M-x 之后输入一个命令名。
C-z     挂起（windows下最小化，linux下后台挂起fg激活）

M-x recover 恢复自动保存的文件
M-x auto-fill-mode 开启自动折行辅模式（再次运行命令关闭自动折行）
C-u 100 C-x f  设置行边界为100个字符
M-q            手动折行
C-s            向前搜索
C-s C-s        重复刚才的查找操作
C-s C-w           递增查找，光标位置的单词用作查找字符串
C-s C-y           递增查找，光标位置到行尾用作查找字符串
C-s M-y           递增查找，删除环中的字符用作查找字符串
C-r            向后搜索
C-r C-r           重复刚才的查找造作
M-%            查找替换（逐步提示）
M-x replace-string  查找替换光标所在行以下所有内容，无需提示
C-M-v          向上滚动下面窗口
C-M-S-v        向下滚动下面窗口
C-x o          跳转到其他窗口
C-x 4 C-f      在新窗口中新建一个文件

C-x (  录制宏
C-x )  结束录制
C-x e  调用宏
M-x name   调用保存的宏
C-u C-x (  宏尾部追加宏内容
M-x name-last-kbd-macro 保存宏

M-x insert-kbd-macro 将宏代码插入到文件
M-n M-x  jjjjjj

快捷键设想
移动项
C-e    上
C-s    下
C-a    左
C-d    右
C-q    行首
C-e    行尾
C-r    上一页
C-f    下一页
C-S-r  文件首
C-S-f  文件尾
C-z    撤销
C-x    剪切
C-c    复制
C-v    粘贴
M-x    替换（C-x）
M->    替换（M-x）
ESC    取消命令

编辑项目
C-w    剪切到行首
C-r    剪切到行尾
C-w    文件首
C-s    文件尾
C-a    上移一个单词
C-d    下移一个单词
C-r
C-f
C-SPC 设定选区
C-z 撤销
S-SPC
M-1
M-2
M-3
M-4
M-5
M-6
M-`
tab 代替ctrl-x  两下tab缩进
ESC 3 执行三次下一个命令
M-` 重新执行刚才的命令（C-u)
C-x ** 执行一个其他命令

*** 柜型编辑
| C-x r k | 剪切一个矩形块                   |
| C-x r y | 粘贴一个矩形块                   |
| C-x r o | 插入一个矩形块                   |
| C-x r c | 清除一个矩形块(使其变成空白)     |
| C-x r t | 在选定区域的所有列前插入样的字符 |

C-g     取消当前命令
C-/     撤销命令
C-u     命令执行次数（默认4次）
    C-u 8 C-f   向前移动8个字符
    C-u 8 *     输入8个星号
C-x z 重复上一条命令。可以一直按 z 不断执行，非常方便！
*** 帮助
    键盘操作 　　命令名称 　　回答的问题
    C-h c 　　describe-key-briefly 　　这个按键组合将运行哪个命令
    C-h k 　　describe-key 　　这个按键组合将运行哪个命令？这个命令的作用是什么
    C-h l 　　view-lossage 　　最近输入的100个字符是什么
    C-h w 　　where-is 　　这个命令的按键绑定是什么
    C-h f 　　describe-function 　　这个函数的作用是什么
    C-h v 　　describe-variable 　　这个变量的含义是什么？它有哪些可取值
    C-h m 　　describe-mode 　　查看当前编辑缓冲区所在编辑模式的有关资料
    C-h b 　　describe-bindings 　　这个缓冲区都有哪些按键绑定
    C-h s 　　describe-syntax 　　这个编辑缓冲区使用的是哪个语法表
    C-h i 　　info 　　启动文档阅读器Info程序
    C-h C-f  Info-goto-emacs-command-node 　　启动文档阅读器Info程序，并前进到指定的结点；这个帮助命令的参数是一个命令名
    C-h C-k  Info-goto-emacs-key-command-node 　　启动文档阅读器Info程序，并前进到指定的结点；这个帮助命令的参数是对应于某个命令的按键组合
    C-h p 　　finder-by-keyword 　　沿着这个命令弹出的菜单可以查到关于安装在本系统上的Emacs LISP程序包资料
*** 文件操作
    C-x C-f    打开/新建一个文件
    C-x C-s    保存文件
    C-x C-w    另存为文件
    C-x C-v    关闭当前缓冲区文件并打开新文件
    C-x i      在当前光标处插入文件
    C-x b      新建/切换缓冲区
    C-x C-b    显示缓冲区列表
    C-x k      关闭当前缓冲区
    C-x C-c    关闭e

** emacs 命令速查
http://www.linuxidc.com/Linux/2012-08/68300.htm
http://blog.csdn.net/shuxiao9058/article/details/7420342
http://www.educity.cn/linux/1606885.html
# linux
## 软件安装
### pacman
    -----------------------------+-----------------------------------------------------------------------------
     同步与升级
    -----------------------------+-----------------------------------------------------------------------------
     pacman -Syy                  本地包数据库和远程的软件仓库同步
     pacman -Syu                  同时同步软件库并更新系统到最新状态
    -----------------------------+-----------------------------------------------------------------------------
     安装软件包
    -----------------------------+-----------------------------------------------------------------------------
     pacman -S package1 package2  安装或者升级单个软件包，或者一列软件包（包含依赖包）
     pacman -Sy package           同步包数据库后再执行安装
    -----------------------------+-----------------------------------------------------------------------------
     卸载软件包
    -----------------------------+-----------------------------------------------------------------------------
     pacman -R package_name       删除单个软件包，保留其全部已经安装的依赖关系
     pacman -Rs package_name      删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：
    -----------------------------+-----------------------------------------------------------------------------
     搜索包
    -----------------------------+-----------------------------------------------------------------------------
     pacman -Ss 关键字            这将搜索含关键字的包。
     pacman -Qi 包名              查看有关包的信息。
     pacman -Ql 包名              列出该包的文件。
    -----------------------------+-----------------------------------------------------------------------------
     pacman -Sw 包名              只下载包，不安装。
     pacman -Sc Pacman            下载的包文件位于 /var/cache/pacman/pkg/ 目录。该命令将 清理未安装的包文件。
     pacman -Scc                  清理所有的缓存文件。
     pacman -U                    安装一个本地包（不从源里）：
    -----------------------------+-----------------------------------------------------------------------------
*** yum
*** apt-get
** 系统信息
*** 系统资源
**** uname
     uname -a #
**** hostname
     vim /etc/sysconfig/network
**** w
**** uptime
**** vmstat
    vmstat -n 5 每五秒刷新一次
    vmstat 2 6 每两秒刷新一次，刷新六次后自动结束
    si (swap in) 交换空间写入
    so (swap out) 交换空间读取
    bi 块写入
    bo 块读出
    wa 表示CPU行待数据而没有处理指令的时间百分比

**** dstat
     dstat
     dstat 号称各种资源统计工具，其目的是想替代vmstat,iostat,netstat,ifstat等各种单一统计工具，从而做到All in one。 dstat用Python语言编写。
     dstat能够清晰显示每列的信息，特别是单位及大小很明确，不会在单位换算上犯迷糊和失误。最重要的是，因为它是基于模块化设计，因此我们可以很容易的写一个插件来收集我们需要的统计信息。
     另外，dstat的输出还可以导出为CSV格式文件，从而可以在电子表格工具里分方便的生成统计图形。
     目前dstat的插件已经相当多了

**** top
**** pstree
名称：pstree
使用权限：所有使用者
使用方式：
pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]
pstree -V
说明：将所有行程以树状图显示, 树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root) ,如果有指定使用者 id , 则树状图会只显示该使用者所拥有的行程
参数：
-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号
-c 如果有重覆的行程名, 则分开列出 (预设值是会在前面加上 *

**** ps
     标准语法格式：
     ps -e # 查看所有的进程信息
     ps -ef # 全格式显示进程信息
     BSD语法格式：
     ps -ax
     ps -aux
     UID或USER代表进程执行用户
     PID为进程的唯一编号
     PPID为父进程ID编号
     %CPU代表CPU占用率
     %MEM代表内存点用率
     VSZ代表进程所使用的虚拟内存大小（单位为KB）
     RSS代表进程所使用的物理内存大小（单位为KB）
     TTY代表终端
     STIME或START代表进程启动时间
     STAT代表进程状态（D：不可中断的进程、R：正在运行的进程、S正在睡眠的进程、T：停止或被追踪的进程、X：死掉的进程、Z：僵尸进程）
     TIME代表进程占有CPU的总时间
     CMD或 COMMAND代表进程命令


     ps aux
     ps auxf
     ps -ef
     ps -le | grep mysql 查看有没有启动
     ps 可以查看使用的哪个shell程序
     ps -C apache2  #通过名字或者进程id显示进程
     ps -f -u www-data # 使用"-u"选项后跟用户名来过滤所属用户的进程。多个用户名可以用逗号分隔。

     ps不加参数，只显示当前控制台当前进程
     a显示每一个控制台当前进程
     u类似top显示方式，显示更多的项目
     x显示后台进程，[]括号中的不是进程，是内核线程。不占用用户空间的内存。
     f显示进程父子关系。


名称：ps
使用权限：所有使用者
使用方式：ps [options] [--help]
说明：显示瞬间行程 (process) 的动态
参数：
ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义
-A 列出所有的行程
-w 显示加宽可以显示较多的资讯
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的行程
au(x) 输出格式 :
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
USER: 行程拥有者
PID: pid
%CPU: 占用的 CPU 使用率
%MEM: 占用的记忆体使用率
VSZ: 占用的虚拟记忆体大小
RSS: 占用的记忆体大小
TTY: 终端的次要装置号码 (minor device number of tty)
STAT: 该行程的状态:
D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)
R: 正在执行中
S: 静止状态
T: 暂停执行
Z: 不存在但暂时无法消除
W: 没有足够的记忆体分页可分配
<: 高优先序的行程
N: 低优先序的行程
L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
START: 行程开始时间
TIME: 执行的时间
COMMAND:所执行的指令
范例：
ps
PID TTY TIME CMD
2791 ttyp0 00:00:00 tcsh
3092 ttyp0 00:00:00 ps
% ps -A
PID TTY TIME CMD
1 ? 00:00:03 init
2 ? 00:00:00 kflushd
3 ? 00:00:00 kpiod
4 ? 00:00:00 kswapd
5 ? 00:00:00 mdrecoveryd
.......
% ps -aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.7 1096 472 ? S Sep10 0:03 init [3]
root 2 0.0 0.0 0 0 ? SW Sep10 0:00 [kflushd]
root 3 0.0 0.0 0 0 ? SW Sep10 0:00 [kpiod]
root 4 0.0 0.0 0 0 ? SW Sep10 0:00 [kswapd]
........

ps aux
ps auxf
ps -ef
ps -le | grep mysql 查看有没有启动
ps 可以查看使用的哪个shell程序

ps不加参数，只显示当前控制台当前进程
a显示每一个控制台当前进程
u类似top显示方式
x显示后台进程
f显示进程父子关系。


名称：ps
使用权限：所有使用者
使用方式：ps [options] [--help]
说明：显示瞬间行程 (process) 的动态
参数：
ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义
-A 列出所有的行程
-w 显示加宽可以显示较多的资讯
-au 显示较详细的资讯
-aux 显示所有包含其他使用者的行程
au(x) 输出格式 :
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
USER: 行程拥有者
PID: pid
%CPU: 占用的 CPU 使用率
%MEM: 占用的记忆体使用率
VSZ: 占用的虚拟记忆体大小
RSS: 占用的记忆体大小
TTY: 终端的次要装置号码 (minor device number of tty)
STAT: 该行程的状态:
D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)
R: 正在执行中
S: 静止状态
T: 暂停执行
Z: 不存在但暂时无法消除
W: 没有足够的记忆体分页可分配
<: 高优先序的行程
N: 低优先序的行程
L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)
START: 行程开始时间
TIME: 执行的时间
COMMAND:所执行的指令
范例：
ps
PID TTY TIME CMD
2791 ttyp0 00:00:00 tcsh
3092 ttyp0 00:00:00 ps
% ps -A
PID TTY TIME CMD
1 ? 00:00:03 init
2 ? 00:00:00 kflushd
3 ? 00:00:00 kpiod
4 ? 00:00:00 kswapd
5 ? 00:00:00 mdrecoveryd
.......
% ps -aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.7 1096 472 ? S Sep10 0:03 init [3]
root 2 0.0 0.0 0 0 ? SW Sep10 0:00 [kflushd]
root 3 0.0 0.0 0 0 ? SW Sep10 0:00 [kpiod]
root 4 0.0 0.0 0 0 ? SW Sep10 0:00 [kswapd]
........

**** vmstat
*** cpu
**** cpu核心数
1. 查看物理cpu个数
cat /proc/cpuinfo |grep "physical id" |sort |uniq |wc -l
2. 每个物理cpu核心数
cat /proc/cpuinfo |grep "cpu cores" | uniq
3. 逻辑cpu个数
cat /proc/cpuinfo |grep "processor" |wc -l
*** 内存
**** free
     free -m
     -t显示总的内存
     -b字节显示
     -m以兆显示
     free -s 5每隔5秒钟刷新一次
     实例：
     free -sm 5


     功能说明：显示内存状态。
     语　　法： free [-bkmotV][-s <间隔秒数>]
     补充说明：free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。
     参　　数：
     -b 　以Byte为单位显示内存使用情况。
     -k 　以KB为单位显示内存使用情况。
     -m 　以MB为单位显示内存使用情况。
     -o 　不显示缓冲区调节列。
     -s<间隔秒数> 　持续观察内存使用状况。
     -t 　显示内存总和列。
     -V 　显示版本信息。

*** 硬盘
**** iostat
     其各项的含义分别是：

     rrqm/s: 每秒进行 merge 的读操作数目.即 delta(rmerge)/s
     wrqm/s: 每秒进行 merge 的写操作数目.即 delta(wmerge)/s
     r/s: 每秒完成的读 I/O 设备次数.即 delta(rio)/s
     w/s: 每秒完成的写 I/O 设备次数.即 delta(wio)/s
     rsec/s: 每秒读扇区数.即 delta(rsect)/s
     wsec/s: 每秒写扇区数.即 delta(wsect)/s
     rkB/s: 每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节.(需要计算)
     wkB/s: 每秒写K字节数.是 wsect/s 的一半.(需要计算)
     avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区).delta(rsect+wsect)/delta(rio+wio)
     avgqu-sz: 平均I/O队列长度.即 delta(aveq)/s/1000 (因为aveq的单位为毫秒).
     await: 平均每次设备I/O操作的等待时间 (毫秒).即 delta(ruse+wuse)/delta(rio+wio)
     svctm: 平均每次设备I/O操作的服务时间 (毫秒).即 delta(use)/delta(rio+wio)
     %util: 一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的.即 delta(use)/s/1000 (因为use的单位为毫秒)
     如果 %util 接近 100%,说明产生的I/O请求太多,I/O系统已经满负荷,该磁盘可能存在瓶颈。

     idle小于70% IO压力就较大了,一般读取速度有较多的wait。

     同时可以结合vmstat查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)，另外 await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题。

     avgrq-sz 也是个做 IO 调优时需要注意的地方,这个就是直接每次操作的数据的大小,如果次数多,但数据拿的小的话,其实 IO 也会很小.如果数据拿的大,才IO 的数据会高.也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s.也就是讲,读定速度是这个来决定的。

     svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了),svctm 的大小一般和磁盘性能有关,CPU/内存的负荷也会对其有影响,请求过多也会间接导致 svctm 的增加.await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式.如果 svctm 比较接近 await,说明 I/O 几乎没有等待时间；如果 await 远大于 svctm,说明 I/O 队列太长,应用得到的响应时间变慢,如果响应时间超过了用户可以容许的范围,这时可以考虑更换更快的磁盘,调整内核 elevator 算法,优化应用,或者升级 CPU。

     队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标,但由于 avgqu-sz 是按照单位时间的平均值,所以不能反映瞬间的 I/O 洪水。

     有时间的话，我会单独写几个帖子来说说iostat。
**** fdisk

    fdisk -l
    指令：fdisk
    用途：观察硬盘之实体使用情形与分割硬盘用。
    使用方法：
    一、在 console 上输入 fdisk -l /dev/sda ，观察硬盘之实体使用情形。
    二、在 console 上输入 fdisk /dev/sda，可进入分割硬盘模式。

1. 输入 m 显示所有命令列示。
2. 输入 p 显示硬盘分割情形。
3. 输入 a 设定硬盘启动区。
4. 输入 n 设定新的硬盘分割区。
4.1. 输入 e 硬盘为[延伸]分割区(extend)。
4.2. 输入 p 硬盘为[主要]分割区(primary)。
5. 输入 t 改变硬盘分割区属性。
6. 输入 d 删除硬盘分割区属性。
7. 输入 q 结束不存入硬盘分割区属性。
8. 输入 w 结束并写入硬盘分割区属性。

**** du
    du -sh /opt/oracle # 查看目录大小
du -s # 查看目录
du -h #人类的简写，可读性。
du -h --max-depth=1 # 目录层数
du -h --max-depth=0
du -b（以byte为单位）-k（以K为单位）-m（以M为单位）
du -h --max-depth=1 | sort -n -r #查看目录的磁盘占用情况
du -hs #查看目录大小

Linux 某个目录下的文件按大小排序

df -lh

du -s /usr/* | sort -rn
这是按字节排序

du -sh /usr/* | sort -rn
这是按兆（M）来排序

4.选出排在前面的10个
du -s /usr/* | sort -rn | head

5.选出排在后面的10个
du -s /usr/* | sort -rn | tail

du -h –-max-depth=0 user
du -sh –-max-depth=2 | more

常用命令
du -h --max-depth=1 |grep [TG] |sort #查找上G和T的目录并排序
du -sh #统计当前目录的大小，以直观方式展现

du -h --max-depth=1 |grep 'G' |sort #查看上G目录并排序
du -sh --max-depth=1 #查看当前目录下所有一级子目录文件夹大小
du -h --max-depth=1 |sort #查看当前目录下所有一级子目录文件夹大小 并排序

du -h --max-depth=1 |grep [TG] |sort -nr #倒序排

功能说明：显示目录或文件的大小。
语　　法：du [-abcDhHklmsSx][-L <符号连接>][-X <文件>][--block-size][--exclude=<目录或文件>][--max-depth=<目录层数>][--help][--version][目录或文件]
补充说明：du会显示指定的目录或文件所占用的磁盘空间。
参　　数：
-a或-all 显示目录中个别文件的大小。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-D或--dereference-args 显示指定符号连接的源文件大小。
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
-k或--kilobytes 以1024 bytes为单位。
-l或--count-links 重复计算硬件连接的文件。
-L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。
-m或--megabytes 以1MB为单位。
-s或--summarize 仅显示总计。
-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。
--exclude=<目录或文件> 略过指定的目录或文件。
--max-depth=<目录层数> 超过指定层数的目录后，予以忽略。
--help 显示帮助。
--version 显示版本信息。
**** df
    -i # inode使用量信息
-h # 人性化方式显示信息(1024进制)
-H # 人性化方式显示信息(1000进制)
-T # 显示文件系统类型

显示已挂载的块设备（未挂载无法显示）
df -Th


名称:df
使用权限: 所有使用者>
使用方式: df [选项]... [FILE]...
显示档案系统的状况，或是看所有档案系统的状况(预设值)
-a, --all 包含所有的具有 0 Blocks 的档案系统
--block-size={SIZE} 使用 {SIZE} 大小的 Blocks
-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)
-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024
-i, --inodes 列出 inode 资讯，不列出已使用 block
-k, --kilobytes 就像是 --block-size=1024
-l, --local 限制列出的档案结构
-m, --megabytes 就像 --block-size=1048576
--no-sync 取得资讯前不 sync (预设值)
-P, --portability 使用 POSIX 输出格式
--sync 在取得资讯前 sync
-t, --type=TYPE 限制列出档案系统的 TYPE
-T, --print-type 显示档案系统的形式
-x, --exclude-type=TYPE 限制列出档案系统不要显示 TYPE
-v (忽略)
--help 显示这个帮手并且离开
--version 输出版本资讯并且离开

*** 网卡
**** netstat
-s # 显示各种协议数据统计信息
-n # 使用数字形式的ip、端口号、用户id替代主机、协议、用户等名称信息
-p # 显示进程名称及对应进程id号
-l # 仅显示正在监听的shocket接口信息
-u # 查看udp连接信息
-t # 查看tcp连接信息

查看网关
netstat -r
查看端口
netstat -an
netstat -anp |more
netstat -anp |grep 9060 # 查看WAS端口
netstat -tln 查看监听的端口
netstat -nap 查看监听端口对应的应用

功能说明：显示网络状态。
语　　法：netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]
补充说明：利用netstat指令可让你得知整个Linux系统的网络情况。
参　　数：
-a或--all 显示所有连线中的Socket。
-A<网络类型>或--<网络类型> 列出该网络类型连线中的相关地址。
-c或--continuous 持续列出网络状态。
-C或--cache 显示路由器配置的快取信息。
-e或--extend 显示网络其他相关信息。
-F或--fib 显示FIB。
-g或--groups 显示多重广播功能群组组员名单。
-h或--help 在线帮助。
-i或--interfaces 显示网络界面信息表单。
-l或--listening 显示监控中的服务器的Socket。
-M或--masquerade 显示伪装的网络连线。
-n或--numeric 直接使用IP地址，而不通过域名服务器。
-N或--netlink或--symbolic 显示网络硬件外围设备的符号连接名称。
-o或--timers 显示计时器。
-p或--programs 显示正在使用Socket的程序识别码和程序名称。
-r或--route 显示Routing Table。
-s或--statistice 显示网络工作信息统计表。
-t或--tcp 显示TCP传输协议的连线状况。
-u或--udp 显示UDP传输协议的连线状况。
-v或--verbose 显示指令执行过程。
-V或--version 显示版本信息。
-w或--raw 显示RAW传输协议的连线状况。
-x或--unix 此参数的效果和指定"-A unix"参数相同。
--ip或--inet 此参数的效果和指定"-A inet"参数相同。

** 集群
*** Corosync+Pacemaker+DRBD+MySQL 实现高可用(HA)的MySQL集群
**** Corosync 安装与配置
**** Pacemaker 安装与配置
**** DRBD 安装与配置
**** MySQL 安装与配置
**** crmsh 资源管理
** 使用技巧
** 文件处理
*** mv
　　名称：mv

　　使用权限：所有使用者

　　使用方式：

　　mv [options] source dest

　　mv [options] source... directory

　　说明：将一个档案移至另一档案，或将数个档案移至另一目录。

　　参数：-i 若目的地已有同名档案，则先询问是否覆盖旧档。

　　范例：

　　将档案 aaa 更名为 bbb :

　　mv aaa bbb

　　将所有的C语言程序移至 Finished 子目录中 :

　　mv -i *.c

*** find
    通过以下的命令可以找到系统上所有的设置了suid的文件：
[root@sgrid5 /]# find / -perm -04000 -type f -ls

-empty # 查找空白文件或目录
-group # 按组查找
-user  # 按用户查找
-name  # 按名称查找
-iname  # 按名称查找,不区分大小写
-mtime # 按修改时间查找
-size # 按容量大小查找
-type #按档案类型查找 f文件 d目录 b块设备 c字符型设备 l链接文件
-exec # 对查找的档案执行命令
-a # 并且
-o # 或者

find . -name "file???"
find . -iname "file"  # 不区分大小写
find / -mtime -3 # 查找3天内被修改过的文件
find / -mtime +4 # 查找4天前被修改过的文件
find / -mtime 2  # 查找2天前被修改过的文件
find ./ -size +10M # 查找大于10M的文件
find ./ -type f # 查找所有普通文件
find ./ -user tom # 查找所属用户tom的文件
find ./ -size +1M -exec ls -l {} \;  # 查出大于1M文件后列出文件详细信息
find ./ -size +1M -a -type f # 查找所有大于1M的文件
find /home -amin -10  # 十分钟内存取的文件或目录
find /home -atime -10 # 十小时内存取的文件或目录
find /home -cmin -10  # 十分钟内更改过的文件或目录
find /home -ctime +10 # 十小时前更改过的文件或目录
find /home -size +10k # 大小10K
find / -name filename # 从根目录开始查所有目录
find / -name "*name*"
find / -empty # 查找计算机上的所有空文件
find / -group tom # 查找属组为tom的文件

find / -name "*name*" -ls
find / -name "*name*" -exec file {} \; 查找的文件放到大括号内。查看结果的类型
find / -name "*name*" -exec rm {} \; 删除查找到的内容
find / -name "*name*" -ok rm {} \; 删除查找到的内容 （交互确认）
find /home -user shrek -ls 以例表的形式显示home目录下用户shrek的文件。
find /home -user shrek -a -group shrek -ls 以例表的形式显示用户和用户组同为shrek的文件。（-a 是and的意思，-o 是or的意思 默认是与，-a可省略）
find /home -user shrek -o -group shrek -a -type f -ls (-typef文件，d目录) 重点注意，-a -o的混合使用。
-user -type -name -group -perm -size -mtime -ok -exec -ls
find / -perm -777 -type d -ls 入侵检测给常使用。（-type 前不用加-a 默认就是-a）
递归查找文件内的字符串 find ./ -name ‘*.html’ -exec grep “breadcrumbs.inc.php” ‘{}’ \; -print 这条命令将查找所有包含 breadcrumbs.inc.php 的 HTML 文件。
查找文件
$ find . -maxdepth 1 -type f
# 找出所有用户xxx拥有的文件，拷备到/root/findfiles目录
find / -user xxx -type f -exec cp {} /root/findfiles \;

# 查找/home 目录下文件拥有人是natasha,但拥有组不是natasha的文件复制到  /root/backup文件中
find /home -user natasha -type f  -and ! -group natasha -exec cp {}  /root/backup \;

其它下载，非视频教程内容
find /home -name "*[a-z]",
find /home -name \*txt -o -name \*doc
find /home -regex '.*\.txt\|.*\.doc\|.*\.mp3'
find ./ -regex '.*\(txt\|doc\)'
find /home -name "*txt" -o -name "*doc" -o -name "*mp3"

详解：

名称 : find

用法 : find path -option [ -print ] [ -exec -ok command ] {} \;

使用说明 :

将档案系统内符合expression 的档案列出来。你可以指要档案的名称、类别、时间、大小、权限等不同资讯的组合，只有完全相符的才会被列出来。

find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。

expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。

-mount, -xdev : 只检查和指定目录在同一个档案系统下的档案，避免列出其它档案系统中的档案

-amin n : 在过去 n 分钟内被读取过

-anewer file : 比档案 file 更晚被读取过的档案

-atime n : 在过去 n 天过读取过的档案

-cmin n : 在过去 n 分钟内被修改过

-cnewer file :比档案 file 更新的档案

-ctime n : 在过去 n 天过修改过的档案

-empty : 空的档案-gid n or -group name : gid 是 n 或是 group 名称是 name

-ipath p, -path p : 路径名称符合 p 的档案，ipath 会忽略大小写

-name name, -iname name : 档案名称符合 name 的档案。iname 会忽略大小写

-size n : 档案大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 档案类型是 c 的档案。

d: 目录

c: 字型装置档案

b: 区块装置档案

p: 具名贮列

f: 一般档案

l: 符号连结

s: socket

-pid n : process id 是 n 的档案

你可以使用 ( ) 将运算式分隔，并使用下列运算。

exp1 -and exp2

! expr

-not expr

exp1 -or exp2

exp1, exp2

范例:

将目前目录及其子目录下所有延伸档名是 c 的档案列出来。

# find . -name "*.c"

将目前目录其其下子目录中所有一般档案列出

# find . -ftype f

将目前目录及其子目录下所有最近 20 分钟内更新过的档案列出

# find . -ctime -20

find . -name "*" -exec grep xxx {} ; -print |morexxx为你想要找的字符串

*** cp
    cp aa bb cc /root
 cp -v  显示详细信息
cp /dev/cdrom rhel4-1.iso
cp -R 递归复制整个目录和子目录
cp -r 会把所有source当作普通文件（regular文件）；而cp -r 对特殊文件（管道文件，块设备文件，字符设备文件）会进行创建操作，而不是拷贝。

cp -f 强制复制并覆盖已有的文件，不询问用户

cp -l 链接文件，而不是复制;见下面的说明
cp -u 更新备份文件


cp -p 复制时保持文件权限

cp /dev/cdrom mycd.iso & 后台制作光盘镜像

        -b 同名,备分原来的文件
        -f 强制覆盖同名文件
        -r 按递归方式保留原目录结构复制文件

cp some_file_name{,.bkp}      快速创建一个文件的备份（扩展名是.bkp）











名称：cp

使用权限：所有使用者

使用方式：

cp [options] source dest

cp [options] source... directory

说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。

参数：

-a 尽可能将档案状态、权限等资料都照原状予以复制。

-r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。

-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。

范例：

将档案 aaa 复制(已存在)，并命名为 bbb :

cp aaa bbb

将所有的C语言程序拷贝至 Finished 子目录中 :

cp *.c Finished

*** touch
     touch [-acdmt] 文件
参数：
-a : 仅修改access time。
-c : 仅修改时间，而不建立文件。
-d : 后面可以接日期，也可以使用 --date="日期或时间"
-m : 仅修改mtime。
-t : 后面可以接时间，格式为 [YYMMDDhhmm]


touch 当前目录有同名文件则更新三个时间

touch a 创建一个空文件

touch a b c 同时创建3个文件

touch -d "6/20/10 18:32" aa.txt 创建并修改文件时间

当前没有文件时建立新文件，已有同名文件时对当前文件更新时间。



1. 同时修改文件的修改时间和访问时间

touch -d "2010-05-31 08:10:30" test.doc



2. 只修改文件的修改时间

touch -m -d "2010-05-31 08:10:30" test.doc



3. 只修改文件的访问时间

touch -a -d "2010-05-31 08:10:30" test.doc







　　名称：touch

　　使用权限：所有使用者

　　使用方式：

　　touch [-acfm]

　　[-r reference-file] [--file=reference-file]

　　[-t MMDDhhmm[[CC]YY][.ss]]

　　[-d time] [--date=time] [--time={atime,access,use,mtime,modify}]

　　[--no-create] [--help] [--version]

　　file1 [file2 ...]

　　说明：

　　touch 指令改变档案的时间记录。 ls -l 可以显示档案的时间记录。

　　参数：

　　a 改变档案的读取时间记录。

　　m 改变档案的修改时间记录。

　　c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。

　　f 不使用，是为了与其他 unix 系统的相容性而保留。

　　r 使用参考档的时间记录，与 --file 的效果一样。

　　d 设定时间与日期，可以使用各种不同的格式。

　　t 设定档案的时间记录，格式与 date 指令相同。

　　--no-create 不会建立新档案。

　　--help 列出指令格式。

　　--version 列出版本讯息。

　　范例：

　　最简单的使用方式，将档案的时候记录改为现在的时间。若档案不存在，系统会建立一个新的档案。

　　touch file

　　touch file1 file2

　　将 file 的时间记录改为 5 月 6 日 18 点 3 分，公元两千年。时间的格式可以参考 date 指令，至少需输入MMDDHHmm ，就是月日时与分。

　　touch -c -t 05061803 file

　　touch -c -t 050618032000 file

　　将 file 的时间记录改变成与 referencefile 一样。

　　touch -r referencefile file

　　将 file 的时间记录改成 5 月 6 日 18 点 3 分，公元两千年。时间可以使用 am, pm 或是 24 小时的格式，日期可以使用其他格式如 6 May 2000 。

　　touch -d "6:03pm" file

　　touch -d "05/06/2000" file

　　touch -d "6:03pm 05/06/2000" file

　　touch 也可以制造一个空档(0 byte).例如DHCP Server所需的/etc/dhcpd.leases,dhcpd 必须要有这个档案才能运作正常.[root@/root]#touch /etc/dhcpd.leases[root@/root]#ls -l /etc/dhcpd.leases-rw-r--r-- 1 root root 0 Jul 3 05:50 /etc/dhcpd.leases

　　记得上一次重灌前把/etc下的设定档tar起来，重灌好之后把原有设定还原，却发现系统检查设定档的时间有问题，这个时候用

　　find /etc -name * -exec touch {};

　　就可以把设定档的时间更新到与现在一致了。

*** rm
        ls | grep -v ttt | xargs rm


  　名称：rm

　　使用权限：所有使用者

　　使用方式：rm [options] name...

　　说明：删除档案及目录。

　　参数：

　　-i 删除前逐一询问确认。

　　-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。

　　-r 将目录及以下之档案亦逐一删除。

　　范例：

　　删除所有C语言程序档；删除前逐一询问确认 :

　　rm -i *.c

　　将 Finished 子目录及子目录中所有档案删除 :

　　rm -r Finished
*** cd
    . 当前
    .. 上层目录
    cd ../..
    cd ../abc
    cd ../../abc
    cd ~root 进入别人的主目录
    cd ~ 进入自已的主目录
    cd - 切换目录

*** pwd
    | pwd -p | 显示链接真实地址 |

*** mkdir
|----------------------------------------+--------------|
| mkdir -p ch/kk/jj/ll                   | 递归创建目录 |
| mkdir -p /home/user/{test,test1,test2} |              |
|----------------------------------------+--------------|

*** ls
    ls -ld /root       # 查看root自身的详细信息
    ls -lh             # 人性化显示容量信息
    ls -lt             # 查看档案信息并以修改时间排序
    ls -Z              # 显示selinux属性
    ls -tlr            # 按文件修改时间以列表形式倒序显示
    ls -d */           # 只查看目录
    ls -d .*           # 查看隐藏文件
    ls -l | grep -v ^d # 不显示目录
    ls -l | grep ^-    # 只显示文件
    ls -1              # 参数是阿拉伯数字，以单例形式只显示文件名
    ls -l  # 查看mtime
    ls -lc # 查看ctime
    ls -lu # 查看atime
    ctime是在写入文件、更改属主、权限或着链接时随Inode的内容更改而变化的；
    mtime是在写入文件时随文件内容的更改而变化的；
    atime是在读取文件或者执行文件时变化的。

ls |grep -v chwin |xargs rm 删除chwin以外的所有文件
ll /etc/init.d/ | wc -l 查看有多少个文件和子目录
ls /etc/ -l |grep '^d' |wc -l查看有多少个子目录
ls -ld chwin/ 查看目录本身，而不是目录里的子目录-d不能单独使用，要和其它参数合用
-l # 以长格式列出文件，包括文件大小、日期和时间、属性
-d # 查看目录本身，而不是目录里的子目录
-h # 人性化易读格式。用 k、M、G 等来标识文件大小。必须和l连用
-t # 最后修改时间排序
-S # 文件大小排序
-r # 与一个排序开关组合起来使用，逆序排列。
-F # 文件名追加类型符号
-a # 显示目录中所有的文件，包括隐藏文件
-R # 递归显示目录及子目录所有文件
-k # 显示文件大小以k为单位
-i # 显示文件 i 节点号
名称 : ls

使用权限 : 所有使用者

使用方式 : ls [-alrtAFR] [name...]

说明 : 显示指定工作目录下之内容（列出目前工作目录所含之档案及子目录)。

参数 :

-a 显示所有档案及目录 (ls内定将档案名或目录名称开头为"."的视为隐藏档，不会列出)

-l 除档案名称外，亦将档案型态、权限、拥有者、档案大小等资讯详细列出

-r 将档案以相反次序显示(原定依英文字母次序)

-t 将档案依建立时间之先后次序列出

-A 同 -a ，但不列出 "." (目前目录) 及 ".." (父目录)

-F 在列出的档案名称后加一符号；例如可执行档则加 "*", 目录则加 "/"

-R 若目录下有档案，则以下之档案亦皆依序列出

范例：

列出目前工作目录下所有名称是 s 开头的档案，愈新的排愈后面 :

ls -ltr s*

将 /bin 目录以下所有目录及档案详细资料列出 :

ls -lR /bin

列出目前工作目录下所有档案及目录；目录于名称后加 "/", 可执行档于名称后加 "*" :

ls -AF

*** stat
    stat a.txt
    查看文件建立时间、修改时间、访问时间。
    Access: 文件最近一次被访问的时间
    Modify: 文件内容最近一次被修改的时间
    Change: 文件属性最近一次被改变的时间
    假如用cat命令将文件a.txt的内容输出到终端（ 执行 cat a.txt）, 那么只有a.txt的Access就被刷新了
    假如我们把当前的时间追加到a.txt(执行 date >> a.txt) ， 那么a.txt的Modify和Change都被刷新
    假如我们把a.txt的权限改为777(执行 chmod 777 a.txt) , 那么只有a.txt的Change被刷新
    假如我们用vi命令把文件a.txt打开, 然后保存退出，那么a.txt的Access，Modify和Change都被刷新
    功能说明：显示inode内容。
    语　　法：stat [文件或目录]
    补充说明：stat以文字的格式来显示inode的内容。
** 备份
*** rsync
*** tar
    -c # 创建打包文件
-r # 追加文件到打包文档
-t # 列出打包文档的内容(要与f连用)
-x # 释放打包文件
-C # 指定解压路径
-f # 指定打包后的文件名称
-j # 打包后通过bzip2格式压缩
-z # 打包后通过gzip格式压缩
--delete #从打包文件中删除文件
--remoce-files # 打包后删除源文件
压缩

tar –cvf jpg.tar *.jpg      # 将目录里所有jpg文件打包成tar.jpg
tar –zcvf jpg.tar.gz *.jpg  # 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz
tar –jcvf jpg.tar.bz2 *.jpg # 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2
tar –Zcvf jpg.tar.Z *.jpg   # 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z
解压

tar –xvf file.tar                 # 解压 tar包
tar -xzvf file.tar.gz             # 解压tar.gz
tar -xjvf file.tar.bz2            # 解压 tar.bz2
tar –xZvf file.tar.Z              # 解压tar.Z
tar -zxvf file.tar.gz -C /root/kk # 指定解压目录
查看包中内容

tar -tf abc.tar.gz
总结

1、*.tar 用 tar –xvf 解压
2、*.gz 用 gzip -d或者gunzip 解压
3、*.tar.gz和*.tgz 用 tar –xzf 解压
4、*.bz2 用 bzip2 -d或者用bunzip2 解压
5、*.tar.bz2用tar –xjf 解压
6、*.Z 用 uncompress 解压
7、*.tar.Z 用tar –xZf 解压
tar
-c: 建立压缩档案
-x：解压
-t：查看内容
-r：向压缩归档文件末尾追加文件
-u：更新原压缩包中的文件
这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。
-z：有gzip属性的
-j：有bz2属性的
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出
下面的参数-f是必须的
-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。
# tar -cf all.tar *.jpg
这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。
# tar -rf all.tar *.gif
这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。
# tar -uf all.tar logo.gif
这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。
# tar -tf all.tar
这条命令是列出all.tar包中所有文件，-t是列出文件的意思
# tar -xf all.tar
这条命令是解出all.tar包中所有文件，-x是解开的意思
***
功能说明：备份文件。
语　　法：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]
补充说明：tar是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。
参　　数：
-A或--catenate 新增温暖件到已存在的备份文件。
-b<区块数目>或--blocking-factor=<区块数目> 设置每笔记录的区块数目，每个区块大小为12Bytes。
-B或--read-full-records 读取数据时重设区块大小。
-c或--create 建立新的备份文件。
-C<目的目录>或--directory=<目的目录> 切换到指定的目录。
-d或--diff或--compare 对比备份文件内和文件系统上的文件的差异。
-f<备份文件>或--file=<备份文件> 指定备份文件。
-F<Script文件>或--info-script=<Script文件> 每次更换磁带时，就执行指定的Script文件。
-g或--listed-incremental 处理GNU格式的大量备份。
-G或--incremental 处理旧的GNU格式的大量备份。
-h或--dereference 不建立符号连接，直接复制该连接所指向的原始文件。
-i或--ignore-zeros 忽略备份文件中的0 Byte区块，也就是EOF。
-k或--keep-old-files 解开备份文件时，不覆盖已有的文件。
-K<文件>或--starting-file=<文件> 从指定的文件开始还原。
-l或--one-file-system 复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。
-L<媒体容量>或-tape-length=<媒体容量> 设置存放每体的容量，单位以1024 Bytes计算。
-m或--modification-time 还原文件时，不变更文件的更改时间。
-M或--multi-volume 在建立，还原备份文件或列出其中的内容时，采用多卷册模式。
-N<日期格式>或--newer=<日期时间> 只将较指定日期更新的文件保存到备份文件里。
-o或--old-archive或--portability 将资料写入备份文件时使用V7格式。
-O或--stdout 把从备份文件里还原的文件输出到标准输出设备。
-p或--same-permissions 用原来的文件权限还原文件。
-P或--absolute-names 文件名使用绝对名称，不移除文件名称前的"/"号。
-r或--append 新增文件到已存在的备份文件的结尾部分。
-R或--block-number 列出每个信息在备份文件中的区块编号。
-s或--same-order 还原文件的顺序和备份文件内的存放顺序相同。
-S或--sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。
-t或--list 列出备份文件的内容。
-T<范本文件>或--files-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。
-u或--update 仅置换较备份文件内的文件更新的文件。
-U或--unlink-first 解开压缩文件还原文件之前，先解除文件的连接。
-v或--verbose 显示指令执行过程。
-V<卷册名称>或--label=<卷册名称> 建立使用指定的卷册名称的备份文件。
-w或--interactive 遭遇问题时先询问用户。
-W或--verify 写入备份文件后，确认文件正确无误。
-x或--extract或--get 从备份文件中还原文件。
-X<范本文件>或--exclude-from=<范本文件> 指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。
-z或--gzip或--ungzip 通过gzip指令处理备份文件。
-Z或--compress或--uncompress 通过compress指令处理备份文件。
-<设备编号><存储密度> 设置备份用的外围设备编号及存放数据的密度。
--after-date=<日期时间> 此参数的效果和指定"-N"参数相同。
--atime-preserve 不变更文件的存取时间。
--backup=<备份方式>或--backup 移除文件前先进行备份。
--checkpoint 读取备份文件时列出目录名称。
--concatenate 此参数的效果和指定"-A"参数相同。
--confirmation 此参数的效果和指定"-w"参数相同。
--delete 从备份文件中删除指定的文件。
--exclude=<范本样式> 排除符合范本样式的问家。
--group=<群组名称> 把加入设备文件中的文件的所属群组设成指定的群组。
--help 在线帮助。
--ignore-failed-read 忽略数据读取错误，不中断程序的执行。
--new-volume-script=<Script文件> 此参数的效果和指定"-F"参数相同。
--newer-mtime 只保存更改过的文件。
--no-recursion 不做递归处理，也就是指定目录下的所有文件及子目录不予处理。
--null 从null设备读取文件名称。
--numeric-owner 以用户识别码及群组识别码取代用户名称和群组名称。
--owner=<用户名称> 把加入备份文件中的文件的拥有者设成指定的用户。
--posix 将数据写入备份文件时使用POSIX格式。
--preserve 此参数的效果和指定"-ps"参数相同。
--preserve-order 此参数的效果和指定"-A"参数相同。
--preserve-permissions 此参数的效果和指定"-p"参数相同。
--record-size=<区块数目> 此参数的效果和指定"-b"参数相同。
--recursive-unlink 解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。
--remove-files 文件加入备份文件后，就将其删除。
--rsh-command=<执行指令> 设置要在远端主机上执行的指令，以取代rsh指令。
--same-owner 尝试以相同的文件拥有者还原问家你。
--suffix=<备份字尾字符串> 移除文件前先行备份。
--totals 备份文件建立后，列出文件大小。
--use-compress-program=<执行指令> 通过指定的指令处理备份文件。
--version 显示版本信息。
--volno-file=<编号文件> 使用指定文件内的编号取代预设的卷册编号。
tar 实现增量备份
博客分类：
linux
MySQL
使用 tar -g 参数进行增量备份实验
完整备份:
#执行完整备份
tar -g snapshot -zcf back.tar.gz back
#查看 tarball 内容
[huzi@mail ~]$ tar ztf back.tar.gz
back/
back/readme.txt
back/rmmysql_back.sh
back/mysqlbackup.sh
back/tuning-primer.sh
back/iptables.sh
back/backup.sh
back/MYSQL_BACKUP.sh
back/read.sh
back/backup.sh.bak
back/iptables
增量备份:
#新增一个档案
cp MySQLBackup.log back
#执行第一次的增量备份 (注意 tarball 档名)
tar -g snapshot -zcf back_incremental_1.tar.gz back
#查看 tarball 内容
[huzi@mail ~]$ tar ztf back_incremental_1.tar.gz
back/
back/MySQLBackup.log
#执行第二次的增量备份 (注意 tarball 档名)
tar -g snapshot -zcf backup_incremental_2.tar.gz back
#查看 tarball 内容
[huzi@mail ~]$ tar ztf back_incremental_2.tar.gz
back/
back/iptables
还原备份资料:
#清空测试资料
rm -rf test
#开始进行资料还原
tar zxf backup_full.tar.gz
tar zxf backup_incremental_1.tar.gz
tar zxf backup_incremental_2.tar.gz
#查看测试资料
[huzi@mail ~]$ tar zxvf back.tar.gz
    back/
    back/MYSQL_BACKUP.sh
    back/backup.sh
    back/backup.sh.bak
    back/iptables.sh
    back/mysqlbackup.sh
    back/read.sh
    back/readme.txt
    back/rmmysql_back.sh
    back/tuning-primer.sh
    [huzi@mail ~]$ tar zxvf back_incremental_1.tar.gz
back/
back/MySQLBackup.log
[huzi@mail ~]$ tar zxvf back_incremental_2.tar.gz
    back/
    back/iptables
    [huzi@mail ~]$ ls back
backup.sh      iptables.sh      MYSQL_BACKUP.sh rmmysql_back.sh
backup.sh.bak MySQLBackup.log readme.txt       tuning-primer.sh
iptables       mysqlbackup.sh   read.sh
使用 tar -u 参数进行增量备份
第一次备份:
#备份资料
tar czvf back.tar.gz back
#查看 tarball 内容
[huzi@mail ~]$ tar ztf back.tar.gz
back/
back/readme.txt
back/rmmysql_back.sh
back/mysqlbackup.sh
back/tuning-primer.sh
back/iptables.sh
back/backup.sh
back/MYSQL_BACKUP.sh
back/read.sh
back/backup.sh.bak
back/iptables
增量备份:
#新增一个档案, 并异动一个档案内容
cp MySQLBackup.log back
#执行增量备份 (-u 参数只能执行於未压缩的 tarball)
gunzip backup.tar.gz
tar uf backup.tar back
gzip backup.tar
#查看 tarball 内容
tar ztf backup.tar.gz
[huzi@mail ~]$ tar ztf back.tar.gz
    back/
    back/readme.txt
    back/rmmysql_back.sh
    back/mysqlbackup.sh
    back/tuning-primer.sh
    back/iptables.sh
    back/backup.sh
    back/MYSQL_BACKUP.sh
    back/read.sh
    back/backup.sh.bak
    back/iptables
    back/
    back/MySQLBackup.log
    [huzi@mail ~]$
还原备份资料:
#解包 tarball
tar zxf backup.tar.gz

*** gzip
    gzip abc.txt   #压缩一个文件到.gz
gzip -d abc.txt.gz  #解压一个文件

功能说明：压缩文件。
语　　法：gzip [-acdfhlLnNqrtvV][-S <压缩字尾字符串>][-<压缩效率>][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S <压缩字尾字符串>][-<压缩效率>][--best/fast][目录]
补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。
参　　数：
-a或--ascii 　使用ASCII文字模式。
-c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
-d或--decompress或----uncompress 　解开压缩文件。
-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
-h或--help 　在线帮助。
-l或--list 　列出压缩文件的相关信息。
-L或--license 　显示版本与版权信息。
-n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
-N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
-q或--quiet 　不显示警告信息。
-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
-S<压缩字尾字符串>或----suffix<压缩字尾字符串> 更改压缩字尾字符串。
-t或--test 　测试压缩文件是否正确无误。
-v或--verbose 　显示指令执行过程。
-V或--version 　显示版本信息。
-<压缩效率> 压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
--best 　此参数的效果和指定"-9"参数相同。
--fast 　此参数的效果和指定"-1"参数相同。

***
** 磁盘管理
*** mount
   mount -o acl /dev/sdb /mnt  # 挂载时打开acl功能（根分区默认是打开的，其他分区需要手工打开）
   mount -o loop -t iso9600 /rhel4-1.iso /media/cdrom/ # 将本地ISO文件挂载到指定目录
   mount /192.168.1.250:/var/ftp/pub /media/cdrom      # 挂载FTP文件服务器目录到本地目录
   mount -t ext4 -o rw /dev/vg0/lv0 /database          # 以读写模式挂载EXT4文件系统逻辑卷
   mount -t iso9660 /dev/cdrom /media/cdrom/           # 将本地光驱挂载到指定目录
   mount -o loop /loop1.img /mnt/loop1                 # 将本地文件挂载到指定目录，挂载前使用mkfs指定文件系统
   mount -o remount,rw /mnt/loop1 # 以读写模式重新挂载
   mount -o remount,ro /mnt/loop1 # 以只读模式重新挂载
   mount -t vfat /dev/sda1 /mnt/  # 挂载fat32文件系统
   mount -t ntfs /dev/sda1 /mnt/  # 挂载ntfs文件系统
   mount -a                       # 把/etc/fstab中列出的路径全部挂载。
   mount -r                       # 将mount的路径定为read only。
   mount -t smbfs
   -t # 指定文件系统的类型
   iso9600
   ext4
   ext3
   smbfs
   ntfs
   vfat
   -o # 指定挂载选项
   ro, rw # 以只读或读写形式挂载，默认是rw
   sync # 不使用缓存，而是对所有操作直接写入磁盘
   async # 使用缓存，默认是async
   noatime # 每次访问文件时不更新文件的访问时间
   atime # 每次访问文件时更新文件的访问时间
   remount # 重新挂载文件系统
   linux和Windows混装时注意主分区数量 Linux挂载分区报错有可能是这原因
   linux中最多只能由四个IDE设备
   硬盘最多只能由四个主分区，逻辑分区是为了解决主分区数量不能满足系统要求而产生的。
   linux支持FAT32读写和NTFS的只读
   linux所有目录都可以创建独立分区，没有进行分区的子目录都会保存在跟分区中。

名称 : mount
使用权限 : 系统管理者或/etc/fstab中允许的使用者
使用方式 :
mount [-hV]
mount -a [-fFnrsvw] [-t vfstype]
mount [-fnrsvw] [-o options [,...]] device | dir
mount [-fnrsvw] [-t vfstype] [-o options] device dir
说明 :
将某个档案的内容解读成档案系统，然后将其挂在目录的某个位置之上。当这个命令执行成功后，直到我们使用 umnount 将这个档案系统移除为止，这个命令之下的所有档案将暂时无法被调用。
这个命令可以被用来挂上任何的档案系统，你甚至可以用 -o loop 选项将某个一般的档案当成硬盘机分割挂上系统。这个功能对于 ramdisk,romdisk 或是 ISO 9660 的影像档之解读非常实用。
参数
-V
显示程序版本
-h
显示辅助讯息
-v
显示较讯息，通常和 -f 用来除错。
-a
将 /etc/fstab 中定义的所有档案系统挂上。
-F
这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。
-f
通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。
-n
一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。
-s-r
等于 -o ro
-w
等于 -o rw
-L
将含有特定标签的硬盘分割挂上。
-U
将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。
-t
指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。
-o async
打开非同步模式，所有的档案读写动作都会用非同步模式执行。
-o sync
在同步模式下执行。
-o atime
-o noatime
当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。
-o auto
-o noauto
打开/关闭自动挂上模式。
-o defaults
使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.
-o dev
-o nodev-o exec
-o noexec
允许执行档被执行。
-o suid
-o nosuid
允许执行档在 root 权限下执行。
-o user
-o nouser
使用者可以执行 mount/umount 的动作。
-o remount
将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。
-o ro
用唯读模式挂上。
-o rw
用可读写模式挂上。
-o loop=
使用 loop 模式用来将一个档案当成硬盘分割挂上系统。
范例
将 /dev/hda1 挂在 /mnt 之下。

mount /dev/hda1 /mnt
将 /dev/hda1 用唯读模式挂在 /mnt 之下。

mount -o ro /dev/hda1 /mnt
将 /tmp/image.iso 这个光碟的 image 档使用 loop 模式挂在 /mnt/cdrom之下。用这种方法可以将一般网络上可以找到的 Linux 光 碟 ISO 档在不烧录成光碟的情况下检视其内容。

mount -o loop /tmp/image.iso /mnt/cdrom
相关命令umount

** shell编程
*** run-parts
    run-parts dir # 运行目录中的所有脚本
*** echo
    -n # 不输出换行
-e # 支持反斜线开始的转义字符，屏蔽反斜线后面字符的原本意义
使用-e选项可以识别如下含义
\\ # 反斜线
\a # 报警器
\b # 退格键
\c # 不生成格外输出，默认echo会自动添加换行
\f # 输入表单格式，换行后保留光标位置
\n # 换行
\t # 生成水平Tab
\v # 生成垂直Tab

echo -e "\\"                #  输出\符号（默认不能输出\号）
echo -e "\a"                #  蜂鸣器响一声
echo -e "ll\b22"            #  回删一个字符
echo -e "hello\c"           #  不换行，等同于-n选项
echo -e "hello\fthe wrold"  #  表单格式
echo -e "hello\tthe\tworld" #  水平tab键
echo -e "hello\vthe\vworld" #  垂直tab键


echo -en \\033[;31m 红色显示
echo -en \\033[;32m 绿色显示
echo -e "\007 hello" 提示声音
echo -e "\a"     提示声音


2012-09-17 11:28 shell脚本中echo显示内容带颜色[zz] shell脚本中echo显示内容带颜色显示,echo显示带颜色，需要使用参数-e
格式如下：
echo -e "\033[字背景颜色；文字颜色m字符串\033[0m"
例如：
echo -e "\033[41;36m something here \033[0m"
其中41的位置代表底色， 36的位置是代表字的颜色
注：
1、字背景颜色和文字颜色之间是英文的""
2、文字颜色后面有个m
3、字符串前后可以没有空格，如果有的话，输出也是同样有空格
下面是相应的字和背景颜色，可以自己来尝试找出不同颜色搭配
例
echo -e “\033[31m 红色字 \033[0m”
echo -e “\033[34m 黄色字 \033[0m”
echo -e “\033[41;33m 红底黄字 \033[0m”
echo -e “\033[41;37m 红底白字 \033[0m”
字颜色：30—–37
echo -e “\033[30m 黑色字 \033[0m”
echo -e “\033[31m 红色字 \033[0m”
echo -e “\033[32m 绿色字 \033[0m”
echo -e “\033[33m 黄色字 \033[0m”
echo -e “\033[34m 蓝色字 \033[0m”
echo -e “\033[35m 紫色字 \033[0m”
echo -e “\033[36m 天蓝字 \033[0m”
echo -e “\033[37m 白色字 \033[0m”
字背景颜色范围：40—–47
echo -e “\033[40;37m 黑底白字 \033[0m”
echo -e “\033[41;37m 红底白字 \033[0m”
echo -e “\033[42;37m 绿底白字 \033[0m”
echo -e “\033[43;37m 黄底白字 \033[0m”
echo -e “\033[44;37m 蓝底白字 \033[0m”
echo -e “\033[45;37m 紫底白字 \033[0m”
echo -e “\033[46;37m 天蓝底白字 \033[0m”
echo -e “\033[47;30m 白底黑字 \033[0m”
最后面控制选项说明
\33[0m 关闭所有属性
\33[1m 设置高亮度
\33[4m 下划线
\33[5m 闪烁
\33[7m 反显
\33[8m 消隐
\33[30m — \33[37m 设置前景色
\33[40m — \33[47m 设置背景色
\33[nA 光标上移n行
\33[nB 光标下移n行
\33[nC 光标右移n行
\33[nD 光标左移n行
\33[y;xH设置光标位置
\33[2J 清屏
\33[K 清除从光标到行尾的内容
\33[s 保存光标位置
\33[u 恢复光标位置
\33[?25l 隐藏光标
\33[?25h 显示光标



*** 一些表达式
    !!：再次执行上一条命令
    !$：上一条命令的最后一个单词
    {a..b}：按照从a到b顺序的一个数字列表
    {a,b,c}：三个词a,b,c. 可以这样使用 touch /tmp/{foo,bar,baz}
    {$1-$9}：执行shell脚本时的命令行参数
    $0：正在执行的命令名称
    $#：当前启动的命令中传入的参数个数
    $?：上一条命令的执行返回值。
    $$：该shell的进程号。
    $*：从$1开始，启动该shell脚本的所有参数。

** 环境配置
** 文本处理
*** dos2unix
    转换文本格式（换行符）
** 网络
*** uname
    功能说明：显示系统信息。
    语　　法：uname [-amnrsv][--help][--version]
    补充说明：uname可显示电脑以及操作系统的相关信息。
    参　　数：
    -a或--all 　显示全部的信息。
    -m或--machine 　显示电脑类型。
    -n或-nodename 　显示在网络上的主机名称。
    -r或--release 　显示操作系统的发行编号。
    -s或--sysname 　显示操作系统名称。
    -v 　显示操作系统的版本。
    --help 　显示帮助。
    --version 　显示版本信息。
*** ssh
    ssh root@192.168.1.1
    ssh root@192.168.1.1 who
    scp abc.tar root@192.168.1.1:/root/
    -r  # 递归拷贝（复制目录）
    -P  # 传输时保留权限及时间戳
    -C  # 传输时进行压缩

    rsync *.* root@192.168.1.1:/root  # rsync是一种增量同步方式，只会拷贝变换的文件（修改的、新增的、删除的）
    从客户端来看，SSH提供两种级别的安全验证。
    第一种级别（基于口令的安全验证）
    只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，也就是受到“中间人”这种方式的攻击。

    第二种级别（基于密匙的安全验证）
    需要依靠密匙，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。
    用这种方式，你必须知道自己密匙的口令。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。
    第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒。

    客户端包含ssh程序以及像scp（远程拷贝）、slogin（远程登陆）、sftp（安全文件传输）等其他的应用程序。
